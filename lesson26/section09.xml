<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №26" next="hometask.xml" prev="section08.xml" summ="0">
<h2>Реализация - очередь с приоритетами.</h2>
<example>
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
using namespace std;

class QueuePriority
{
	// Очередь
	int * Wait;
	// Приоритет
	int * Pri;
	// Максимальный размер очереди
	int MaxQueueLength;
	// Текущий размер очереди
	int QueueLength;

public:
	// Конструктор
	QueuePriority(int m);

	//Деструктор
	~QueuePriority();

	// Добавление элемента
	void Add(int c,int p); 

	// Извлечение элемента
	int Extract();        

	// Очистка очереди
	void Clear();    

	// Проверка существования элементов в очереди
	bool IsEmpty();    

	// Проверка на переполнение очереди
	bool IsFull();     

	// Количество элементов в очереди
	int GetCount();   

	//демонстрация очереди
	void Show();
};

void QueuePriority::Show(){
	cout&lt;&lt;"\n-------------------------------------\n";
	//демонстрация очереди
	for(int i=0;i&lt;QueueLength;i++){
		cout&lt;&lt;Wait[i]&lt;&lt;" - "&lt;&lt;Pri[i]&lt;&lt;"\n\n";
	}
	cout&lt;&lt;"\n-------------------------------------\n";
}

QueuePriority::~QueuePriority()
{
	//удаление очереди
	delete[]Wait;
	delete[]Pri;
}

QueuePriority::QueuePriority(int m)
{
	//получаем размер
	MaxQueueLength=m;
	//создаем очередь
	Wait=new int[MaxQueueLength];
	Pri=new int[MaxQueueLength];
	// Изначально очередь пуста
	QueueLength = 0;
}

void QueuePriority::Clear()
{
	// Эффективная "очистка" очереди 
	QueueLength = 0;
}

bool QueuePriority::IsEmpty()
{
	// Пуст?
	return QueueLength == 0;
}

bool QueuePriority::IsFull()
{
	// Полон?
	return QueueLength == MaxQueueLength;
}

int QueuePriority::GetCount()
{
	// Количество присутствующих в стеке элементов
	return QueueLength;
}

void QueuePriority::Add(int c,int p)
{
	// Если в очереди есть, то увеличиваем количество
	// значений и вставляем новый элемент
	if(!IsFull()){
		Wait[QueueLength] = c;
		Pri[QueueLength] = p;
		QueueLength++;
	}
}

int QueuePriority::Extract()
{
	// Если в очереди есть элементы, то возвращаем тот, 
	// который вошел первым и сдвигаем очередь	
	if(!IsEmpty()){
		

		//пусть приоритетный элемент - нулевой
		int max_pri=Pri[0];
		//а приоритетный индекс = 0
		int pos_max_pri=0;

		//ищем приоритет
		for(int i=1;i&lt;QueueLength;i++)
			//если встречен более приоритетный элемент
			if(max_pri&lt;Pri[i]){
				max_pri=Pri[i];
				pos_max_pri=i;
			}

		//вытаскиваем приоритетный элемент
		int temp1=Wait[pos_max_pri];
		int temp2=Pri[pos_max_pri];
		
		//сдвинуть все элементы
		for(int i=pos_max_pri;i&lt;QueueLength-1;i++){
			Wait[i]=Wait[i+1];
			Pri[i]=Pri[i+1];
		}
		//уменьшаем количество
		QueueLength--;
		// возврат извлеченного элемента	
		return temp1;
		
	}
	else return -1;
}

void main()
{
	srand(time(0));

	//создание очереди
	QueuePriority QUP(25);

	//заполнение части элементов
	for(int i=0;i&lt;5;i++){
		//значения от нуля до ста 
		//и приоритет от 0 до 13
		QUP.Add(rand()%100,rand()%12);
	}
	//показ очереди
	QUP.Show();

	//извлечение элемента
	QUP.Extract();

	//показ очереди
	QUP.Show();
}
</example>
</lesson>