<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №19" next="section2.xml" prev="index.xml" summ="1">

<h2>Форматирование ввода-вывода средствами языка С. </h2>
<h3>Функция printf()</h3> 
<p>Сегодня мы познакомимся с основными возможностями функции <b>printf()</b>. Эта функция появилась в языке программирования C для организации форматного вывода информации. В связи с тем, что C++ был создан на базе языка C, использование этой функции в программах на C++ в некоторых случаях бывает более удобным, чем применение стандартных потоков <b>cout</b> и <b>cin</b>. В связи с тем, что С++ не за горами, в данном уроке мы перечислим основные особенности использования этой функции. </p>
<tip start="Примечание"> Прототип этой функции находится в заголовочном файле stdio.h. </tip>
<p>Формат, указываемый при обращении к функции <b>printf()</b>, выглядит следующим образом: </p>
<example>
printf (Управляющая_строка,Аргумент1,Аргумент2,...);
<ol>
<li><b>Аргумент1, Аргумент2,...</b> - это печатаемые параметры, которые могут быть переменными, константами или выражениями, вычисляемыми перед выводом на печать. </li>
<li><b>Управляющая_строка</b> - строка символов, показывающая, как должны быть напечатаны параметры. </li>
</ol>
</example>
<p>Самым сложным в использовании этой функции является <b><i>Управляющая_строка</i></b> , задающая формат вывода данных. Помимо обычного текста она содержит <b><i>команды преобразования</i></b>, которые начинаются с символа <b>"%"</b>, за которым следуют символы и цифры, задающие правила вывода аргументов (<b><i>Аргумент1, Аргумент2,...</i></b>). Формат определяется следующим образом: </p>
<example>%[флажки][ширина][.точность][F|N|h|l|L] преобразование</example>
<tip start="Примечание"> Отметим, что конструкции в квадратных скобках могут отсутствовать, а символ "|" (вертикальная черта) свидетельствует о том, что здесь может использоваться одна из перечисленных возможностей. </tip>
<h5>Элементы формата.</h5>
<ol>
<li>
<b>Формат</b> (команда преобразования) начинается с обязательного знака процента. Чтобы вставить в выводимый текст сам знак процента, его нужно указать дважды: <b>%%</b>.
</li>
<li><b>Флажки</b> задают правила выравнивания, знаки "+" и "-", десятичную точку, хвостовые нули и префиксы для восьмеричных и шестнадцатеричных значений. Флажки не являются обязательными. Если они присутствуют, то могут состоять из одного или нескольких указанных в таблице ниже символов.</li>
<center><img src="images\1.jpg" ></img></center>
<li><b>Ширина</b> - задает минимальную ширину поля вывода (в символьных позициях).
<ul><li>Любое свободное пространство обычно заполняется пробелами</li>
<li>Но если значение ширины начинается с цифры <b>0</b>, эти добавляемые пробелы заменяются нулями.</li>
<li>В качестве ширины можно также указать символ * ("звездочка"), что приводит к использованию значения следующего аргумента типа <b>int</b> в качестве ширины поля.</li>
<li>В этом случае задается два значения: целое значение, задающее минимальную используемую ширину, и значение, выводимое в этом поле. </li>
<li>Значение, задающее ширину, должно располагаться <b><i>перед</i></b> выводимым значением.</li>
<li>Если указана нулевая ширина, то вывод производится в поле переменной ширины и дополняется ведущими нулями. </li>
<li>Можно задавать меньшую ширину, чем требуется, для представления значения. </li>
<li>Ширина поля вывода увеличивается по мере необходимости, чтобы обеспечить вывод значения без отсечения.</li></ul> </li>
<li><b>Точность</b> - если в этом месте форматной строки присутствует точка, то следующее за ней значение представляет точность, используемую для представления форматируемого результата. Интерпретация точности зависит от типа форматируемого элемента.
<ul>
<li>За точкой должно следовать целое значение. Это значение по умолчанию равно 0, что означает отсутствие компонента точности. </li>
<li>Для символов преобразования <b>d, i, o, u, x</b> и <b>X</b> по умолчанию это значение равно 1. </li>
<li>Для символов <b>e, E</b> и <b>f</b> по умолчанию это значение равно 6.</li>
<li>Для <b>g</b> и <b>G</b> - переменному числу значащих цифр. </li>
<li>Для символов <b>s</b> и <b>c</b> - полному числу символов.</li>
<li>Для символов преобразования <b>g</b> и <b>G</b> точность представляет максимальное число значащих цифр сформатированного результата. </li>
<li>Для преобразований <b>e, E</b> и <b>f</b> точность равна числу используемых десятичных позиций, а последняя цифра округляется. </li>
<li>В случае использования <b>s</b> точность указывает максимальное число используемых символов строки. </li>
<li>Точность никак не влияет на результат с использованием символа преобразования <b>c</b> - всегда выводится один символ. </li>
<li>Для преобразований <b>d, i, o, u, x</b> и <b>X</b> выводится столько цифр, сколько указано точностью, дополненных, при необходимости, слева цифрами 0</li>
</ul></li>
<li>Один из нескольких <b><i>модификаторов</i></b> позволяет указать характеристики, связанные с размером выводимого значения. Требуемый тип данных выбирается соответствующим <b><i>символом преобразования:</i></b>
<ul>
<li><b>F</b> - дальний (far-) указатель; </li>
<li><b>N</b> - ближний (near-) указатель; </li>
<li><b>h</b> - значение типа short int; </li>
<li><b>l</b> - значение типа long; </li>
<li><b>L</b> - значение типа long double. </li>
</ul></li>
<li><b><i>Преобразование</i></b> - задает тип соответствующего аргумента. Программист сам несет ответственность за правильность типа этого аргумента. Например, если используется символ преобразования <b>g</b>, то аргумент должен быть значением с плавающей точкой. В таблице 2 перечислены все допустимые символы преобразования, причем в каждой отдельной команде можно использовать <b><i>только один</i></b> из указанных символов.</li>
<center><img src="images\2.jpg"></img></center>
</ol>
<h3>Функция scanf().</h3>
<p>А, теперь, рассмотрим основные особенности применения функции <b>scanf()</b>, предназначенной для ввода данных. Так же, как и для функции <b>printf()</b>, для функции <b>scanf()</b> указываются управляющая строка и следующий за ней список аргументов. Обращение к этой функции имеет вид: </p>
<example>
scanf (Управляющая_строка,&amp;Имя1,&amp;Имя2,...,&amp;ИмяN);
<ol>
<li><b>Имя1,Имя2,...,ИмяN</b> - это имена переменных, значения которых надо ввести. Смысл символа <b>"&amp;"</b> перед именем будет раскрыт ниже.</li>
<li><b>Управляющая_строка</b> - это строка символов, которая задает количество и типы вводимых переменных. Делается это так: в формате указывается символ <b>%</b>, за которым следует буква, определяющая <b><i>тип</i></b> вводимой переменной. </li>
</ol>
</example>
<p>Сочетание <b><i>%буква</i></b> является <b><i>спецификацией преобразования</i></b>. При вводе мы будем пользоваться следующими спецификациями: </p>
<ul>
<li><b>%d</b> - ввести целое число; </li>
<li><b>%c</b> - ввести один символ; </li>
<li><b>%s</b> - ввести строку символов. </li></ul>
<p>Спецификации преобразования должны соответствовать количеству и типу вводимых переменных. </p>
<p>При применении функции <b>scanf()</b> мы. Необходимо запомнить два правила. </p>
<ol>
<li>Если нужно ввести некоторое значение и присвоить его переменной одного из основных типов, то перед именем переменной требуется писать символ &amp;, т. е передавать переменную в функцию по ссылке. </li>
<li>Если требуется ввести значение <b><i>строковой переменной</i></b>, то использовать символ <b>&amp;</b> <b><i>не нужно</i></b>. </li></ol>
<p>При обращении к функции <b>scanf()</b> выполнение программы приостанавливается, и нужно ввести значения для указанных переменных, после чего работа программы продолжается. </p>
<p>Остановимся более подробно на содержимом управляющей строки. Она содержит спецификации преобразования, которые используются для непосредственной интерпретации входной последовательности. </p>
<p>Управляющая строка может содержать: </p>
<ul>
<li>пробелы ' ', символы табуляции '\t' и перевода строки '\n', которые просто игнорируются; </li>
<li>обычные символы (кроме символа "%"), которые предполагаются совпадающими с очередными (отличными от символов, перечисленных в предыдущем пункте) символами входного потока; </li>
<li><b><i>спецификации преобразования</i></b>, состоящие из
<ul>
<li>%,</li>
<li>необязательного символа "подавления" присваивания "*", </li>
<li>необязательного числа, задающего максимальную ширину поля и </li>
<li>символа преобразования. </li></ul> </li>
</ul>
<p><b><i>Спецификация преобразования</i></b> управляет преобразованием очередного входного поля. Результат обычно помещается в переменную, на которую ссылается соответствующий параметр. Однако, если присутствует символ "*", то входное поле просто пропускается, и никакого присваивания не производится. </p>
<p>Перечислим основные символы преобразования: </p>
<ul>
<li><b>d</b> - десятичное число; </li>
<li><b>x</b> - шестнадцатеричное число; </li>
<li><b>o</b> - восьмеричное число; </li>
<li><b>c</b> - символ; </li>
<li><b>s</b> – строка символов</li></ul>
<h3>Пример</h3>
<example>
#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;

void main ()
{
      int data,month,year;
      char name[15],town[15];
    
      printf ("What is your name? ");
	  scanf ("%s",name);
      printf ("Enter day, month and year of your birthday.\n Дата: ");
      scanf ("%d%d%d",&amp;data,&amp;month,&amp;year); // ввод через пробел
      printf ("Where you live?"); 
	  scanf ("%s",town);
      printf ("Now, we know you!!!\n");
      printf ("Your name is %s .\n",name);
      printf ("You live in %s your birthday (%d.%d.%d)\n\n",town,data,month,year);
}
</example>
</lesson>
