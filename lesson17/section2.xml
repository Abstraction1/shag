<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №17" next="section4.xml" prev="section1.xml" summ="0">	  

<h2>Битовые операции.</h2>
<p>Только что мы с Вами разобрались с общей теорией, теперь пообщаемся с битовой арифметикой с точки зрения языка С.</p>
<p>В языке C++ существует ряд операций, выполняющихся над разрядами. Они носят название <b><i>битовые операции:</i></b></p>
<ul>
<li><b>унарная операция:</b>
<ul><li><b>инверсия битов (~); 
</b></li></ul></li>
<li><b>бинарные операции:</b>
<ul><li><b>битовое "И" (&amp;);</b></li>
<li><b>битовое "ИЛИ" (|);</b></li>
<li><b>битовое исключающее "ИЛИ" (^);</b></li>
<li><b>сдвиг влево (&lt;&lt;);</b></li>
<li><b>сдвиг вправо (&gt;&gt;);</b></li></ul></li>
</ul>
<p>Остановимся на данных операциях более подробно. </p>
<p><b><i>1. Инверсия битов  (поразрядное отрицание, дополнение до единицы)</i></b> инвертирует биты, т.е. каждый бит со значением 1 получает значение 0 и наоборот. </p>
<p><b><i>2.Битовое "И"</i></b> сравнивает последовательно разряд за разрядом два операнда. Для каждого разряда результат равен 1, тогда и только тогда, когда оба соответствующих разряда операндов равны 1. Так, например, </p>
<example>10010011 &amp; 00111101 = 00010001</example>
<p>потому что только нулевой и четвертый разряды обоих операндов содержат 1. </p>
<p><b><i>3. Битовое "ИЛИ"</i></b> сравнивает последовательно разряд за разрядом два своих операндов. Для каждого разряда результат равен 1 тогда и только тогда, когда любой из соответствующих разрядов операндов равны 1. Так, например, </p>
<example>10010011 | 00111101 = 10111111</example>
<p>потому что все разряды (кроме шестого) в одном из двух операндов имеют значение 1. </p>
<p><b><i>4. Битовое исключающее "ИЛИ"</i></b> сравнивает последовательно разряд за разрядом два своих операндов. Для каждого разряда результат равен 1, если один из двух (но не оба) соответствующих разрядов операндов равен 1. Так, например,</p>
<example>10010011 ^ 00111101 = 10101110 </example>
<p>Заметим, что, поскольку нулевой разряд в обоих операндах имеет значение 1, нулевой разряд результата имеет значение 0. </p>
<p>Описанные выше операции часто используются для установки некоторых битов, причем другие биты остаются неизменными. Они удобны для фильтрации или маскирования битов. </p>
<p><b><i>5. Сдвиг влево</i></b> сдвигает разряды левого операнда влево на число позиций, указанное правым операндом. Освобождающиеся позиции заполняются нулями, а разряды, сдвигаемые за левый предел левого операнда, теряются. Поэтому, например, </p>
<example>
10001010 &lt;&lt; 2  =  00101000 ,
(каждый разряд сдвинулся на две позиции влево).
</example>
<p>Таким образом, <b><i>х&lt;&lt;2</i></b> сдвигает <b><i>х</i></b> влево на 2 позиции, заполняя освобождающиеся позиции нулями (эквивалентно умножению на 4). </p>
<p>Для значений без знака имеем </p>
<example>
10001010  &gt;&gt; 2  = 00100010 ,
(каждый разряд сдвинулся на две позиции).
</example>
<p>Эти две операции выполняют сдвиг, а также эффективное умножение и деление на степени числа 2. </p>
<h5>Пример.</h5> 
<example>
#include &lt;iostream&gt;
using namespace std;
void main (){

      int y=02,x=03,z=01,k;

      k = x|y&amp;z;  
	cout&lt;&lt;k&lt;&lt;" ";  /* Операция  1 */

      k = x|y&amp;~z; 
	cout&lt;&lt;k&lt;&lt;" ";  /* Операция  2 */

      k = x^y&amp;~z;
	cout&lt;&lt;k&lt;&lt;" ";  /* Операция  3 */

      k = x&amp;y&amp;&amp;z;
	  cout&lt;&lt;k&lt;&lt;" ";  /* Операция  4 */

      x = 1;
	y = -1;

      k = !x|x;
	cout&lt;&lt;k&lt;&lt;" ";  /* Операции  5 */

      k = -x|x;
	cout&lt;&lt;k&lt;&lt;" ";    /* Операции  6 */

      k = x^x;
	cout&lt;&lt;k&lt;&lt;" ";    /* Операции  7 */

      x &lt;&lt;= 3;
	cout&lt;&lt;x&lt;&lt;" ";    /* Операции  8 */

      y &lt;&lt;= 3;
	cout&lt;&lt;y&lt;&lt;" ";    /* Операции  9 */

      y &gt;&gt;= 3;
	cout&lt;&lt;y&lt;&lt;" ";    /* Операции 10 */
}
Результат работы программы: 
3 3 1 1 1 -1 0 8 -8 -1 
</example>
   <tip start="Примечание"> Здесь мы с Вами знакомимся с еще одной системой исчисления. Целые константы, начинающиеся с цифры 0, являются <b><i>восьмеричными числами</i></b>. Восьмеричное представление целых чисел особенно удобно, когда приходится работать с поразрядными операциями, так как восьмеричные числа легко переводятся в двоичные. В этой задаче числа 01,02,03 соответствуют числам 1, 2 и 3, так что появление восьмеричных чисел служит намеком, что программа рассматривает значения x, y и z как последовательности двоичных цифр. </tip>
<h5>Комментарии к коду.</h5>
<example>
    Операция 1. 

   x = 03; y = 02; z = 01;
   k = x|y&amp;z;
Вследствие приоритетов операций: k = (x|(y&amp;z));. Самое внутреннее выражение вычисляется первым. 
   k = (x|(02&amp;01));
   02 &amp; 01 = 00000010 &amp; 00000001 = 00000000 = 0
   k = (x|00);
   03 | 00 = 00000011 | 00000000 = 00000011 = 03
   03
</example>
<hr/>
<example>
    Операция 2. 
   x = 03; y = 02; z = 01;
   k = x|y&amp;~z;
   k = (x|(y&amp;(~z)));

   ~00000001 =  11111110   
   02 &amp; 11111110 =  000000010 &amp; 11111110 = 000000010 = 02
   03 | 02 = 00000011 | 000000010 = 00000011 = 03
   3
</example>
<hr/>
<example>
    Операции 3. 
   x = 03; y = 02; z = 01;
   k = x^y&amp;~z;
 
   k = (03^02);
   1
</example>
<hr/>
<example>
    Операции 4. 
   x = 03; y = 02; z = 01;
   k = x&amp;y&amp;&amp;z;
 
   k = ((x&amp;y)&amp;&amp;z);
   k = ((03&amp;02)&amp;&amp;z);
   k = (02&amp;&amp;z);
   k = (true&amp;&amp;z);
   k = (&amp;&amp;01);
   k = (true&amp;&amp;true)
   true или 1
</example>
<hr/>
<example>
Операции 5. 
   x = 01;
   k = !x|x;
 
   k = ((!x)|x);
   k = ((!true)|x);
   k = (false|01);
   k = (0|01);
   1
</example>
<hr/>
<example>
Операции 6. 
   x = 01;
   k = -x|x;

   k = ((-x)|x);
   k = (-01|01);
   -01 | 01  = 11111111 | 00000001 =  11111111 = -1
   -1

</example>
<hr/>
<example>
Операции 7. 
   x = 01;
   k = x^x;
 
   k = (01^01);
   0

</example>
<hr/>
<example>
Операции 8. 
   x = 01;
   x &lt;&lt;= 3;
 
   x = 01&lt;&lt;3;
   01 &lt;&lt; 3 = 000000001 &lt;&lt; 3 =  00001000 = 8
   x = 8;
   8

</example>
<hr/>
<example>
Операции 9. 
   y = -01;
   y &lt;&lt;= 3;
 
   y = -01&lt;&lt;3
   -01 &lt;&lt; 3 = 11111111 &lt;&lt; 3 =  11111000 =  -8
   y = -8;
   -8

</example>
<hr/>
<example>
Операции 10. 
   y = -08;
   y &gt;&gt;= 3;
 
   y = -08&gt;&gt;3;
   -1

</example>
<hr/>
<tip start="Примечание">  В некоторых случаях вместо -1 может получиться другой результат (8191). Появление этого значения объясняется тем, что на некоторых компьютерах при операции сдвига знак числа может не сохраниться. Не все трансляторы языка C гарантируют, что операция сдвига арифметически корректна, поэтому в любом случае более ясным способом деления на 8 было бы явное деление <b><i>y=y/8</i></b>. </tip>
</lesson>
