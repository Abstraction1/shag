<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="”рок є17" next="hometask.xml" prev="section4.xml" summ="1">
<h2>Ѕитовые пол€.</h2>
<p>¬ прошлом уроке мы с ¬ами рассматривали пон€тие <b>структуры</b>. ѕол€ми структур могут быть не только переменные, но и другие образовани€, в частности, <b><i>пол€ битов</i></b>. ’от€ правила €зыка не имеют ограничений на характер этих полей, кроме требовани€, чтобы они помещались в объеме машинного слова, в типичных применени€х пол€ битов служат дл€ хранени€ целых данных (чаще типа <b>unsigned</b>).</p>
<p>ќписание пол€ битов состоит из описани€ типа пол€, его имени и указанного после двоеточи€ размера пол€ в битах, например: <b>unsigned status: 6;</b>. </p>
<p>≈сли им€ пол€ опущено, то создаетс€ скрытое поле. ≈сли размер пол€ битов представлен числом 0, то следующее поле битов начнетс€ с границы машинного слова. </p>
<h5>ѕример.</h5> 
<example>
#include &lt;iostream&gt;
using namespace std;
void Binary(unsigned);
void main()
{
   struct Bits
   { 
     unsigned bit1: 3;
     unsigned bit2: 2;
     unsigned bit3: 3;
   } Good;
   
   Good.bit1 = 4;
   Good.bit2 = 3;
   Good.bit3 = 6;
   cout&lt;&lt;"Show: "&lt;&lt;Good.bit1&lt;&lt;" ";
   cout&lt;&lt;Good.bit2&lt;&lt;" ";
   cout&lt;&lt;Good.bit3&lt;&lt;"\n\n";
   cout &lt;&lt; "Sum: ";
   Binary(Good.bit1 + Good.bit2 + Good.bit3);
} 
// ‘ункци€ выводит на экран двоичное представление числа A.
void Binary (unsigned A) 
{
    int i,N;
    if(A&gt;255)
		N = 15;
    else
		N = 7;
    for (i=N; i >= 0; i--)
    { 
	cout&lt;&lt;((A&gt;&gt;i)&amp;1);
        	if(i==8)
		cout&lt;&lt;" ";
    }
    cout&lt;&lt;"\n\n";
}

</example>
</lesson>
