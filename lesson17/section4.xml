<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №17" next="section5.xml" prev="section2.xml" summ="1">
<h2>Объединения. </h2>
<p>Структура данных <b><i>объединение</i></b> подобна <b><i>структуре</i></b>, однако в каждый момент времени может использоваться (является активным) только <b><i>один из его компонентов</i></b>. Шаблон объединения может задаваться записью вида: </p>
<example>
union
  {
   &lt;имя типа1&gt; &lt;компонента1&gt;;
   &lt;имя типа2&gt; &lt;компонента2&gt;;
        .     .      .
   &lt;имя типаN&gt; &lt;компонентаN&gt;;
  };
</example>
<p>Поля структуры размещаются в оперативной памяти <b><i>одно за другим в той последовательности, в которой перечислены в описании</i></b>. Поля объединений размещаются, начиная с <b><i>одного места в памяти</i></b> и, следовательно, накладываются друг на друга. </p>
<p>Доступ к компонентам объединения осуществляется тем же способом, что и к компонентам структур.</p>
<h5>Пример.</h5> 
<example>
#include &lt;iostream&gt;
using namespace std;

union Test
{
   int a;
   char b;

}kkk;

void main ()
{  
  kkk.a = 65;
  cout&lt;&lt;kkk.a&lt;&lt;" "; // число 65
  cout&lt;&lt;kkk.b;// символ А (соответствующий этому числу)
}
</example> 
<p>В качестве более осмысленного примера объекта типа <b><i>union</i></b> рассмотрим объединение <b><i>geom_fig[1]</i></b>: </p>
<example>
union
  {
   int radius; // Окружность. 
   int a[2]; // Прямоугольник. 
   int b[3]; // Треугольник.
  } geom_fig;

</example>
<p>    В этом примере обрабатывается только активный компонент, то есть компонент, который последним получает свое значение. Например, после присваивания значения компоненту <b><i>radius</i></b> не имеет смысла обращение к массиву <b><i>b</i></b>. </p>
<tip start="Примечание">  Обратите внимание на то, что на одних компьютерах поля битов размещаются слева направо, на других - справа налево. Это значит, что при всей полезности работы с ними, если формат данных, с которыми мы имеем дело, дан нам свыше, то необходимо самым тщательным образом исследовать порядок расположения полей; программы, зависящие от такого рода вещей, не переносимы. </tip>
<h5>Выводы</h5>
<p>Объединения применяются для: </p>
<ul><li>минимизации используемого объема памяти, если в каждый момент времени только один объект из многих является активным; </li>
<li>интерпретации основного представления объекта одного типа, как если бы этому объекту был присвоен другой тип. </li></ul>
<p> Таким образом, после задания рассмотренной структуры данных в программе будет находиться переменная, которая на законных основаниях может хранить "в себе" значения нескольких типов. </p>
</lesson>
