<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №15" next="section3.xml" prev="section1.xml" summ="0">	  

<h2>Примеры на многомерные динамические массивы.</h2>
<h3>Пример 1. Организация двумерного "треугольного" динамического массива.</h3>
<p> Сначала создаётся одномерный массив указателей, а затем каждому элементу этого массива присваивается адрес одномерного массива. При этом размер (количество элементов) каждого нового массива на единицу меньше размера предыдущего. Включённая в квадратные скобки переменная, которая является операндом операции new, позволяет легко сделать это.
</p>
<example>
#include &lt;iostream&gt;
using namespace std;

void main()
{
	int i, j;

	// Переменные для описания характеристик массивов.
	int m1 = 5, wm = 5;
	int **pXArr = new int*[m1];

	for (i = 0; i &lt; m1; i++, wm--) 
		pXArr[i] = new int[m1];

	
	//Заполнение массива нулями и показ его на экран
	for (i = m1 - 1; i &gt;= 0; i--, wm++) {
		for (j = 0; j &lt; wm; j++){
			pXArr[i][j]=0;
			cout&lt;&lt;pXArr[i][j]&lt;&lt;"\t";
		}
		cout&lt;&lt;"\n\n";
	}

	//Последовательное уничтожение двумерного массива треугольной конфигурации…

	for (i = 0; i &lt; m1; i++) 
		delete[]pXArr[i];
	delete[]pXArr;
}
</example>

<h3>Пример 2. Организация трехмерного динамического массива.</h3>

<p>Создание и уничтожение трёхмерного массива требует дополнительной итерации. Однако здесь также нет ничего принципиально нового.</p>
<example>
 #include &lt;iostream&gt;
using namespace std;

void main()
{
	int i, j;

	// Переменные для описания характеристик массивов.
	int m1 = 5, m2 = 5, m3 = 2;
	
	// указатель на указатель на указатель :)
	int ***ppArr;

	// Создание массива
	ppArr = new int**[m1];
	for (i = 0; i &lt;m1; i++) 
		ppArr[i] = new int*[m2];

	for (i = 0; i &lt; m1; i++)
		for (j = 0; j &lt; m2; j++) 
			ppArr[i][j] = new int[m3];
	
	ppArr[1][2][3] = 750; 
	cout &lt;&lt; ppArr[1][2][3] &lt;&lt; "\n"; 

	// Удаление в последовательности, обратной созданию
	for (i = 0; i &lt; m1; i++)
		for (j = 0; j &lt; m2; j++) 
			delete[]ppArr[i][j];

	for (i = 0; i &lt; m1; i++) 
		delete[]ppArr[i];
	delete[] ppArr;
}

</example>
</lesson>
