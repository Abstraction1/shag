<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №15" next="section4.xml" prev="section2.xml" summ="0">
<h2>Перечисляемые типы.</h2>
<p>Перечислимый тип вводится ключевым словом enum и задает набор значений, определяемый пользователем. Набор значений заключается в фигурные скобки и является набором целых именованных констант, представленных своими идентификаторами. Эти константы называются перечислимыми константами. Рассмотрим объявление:</p>
<example>
enum Suit {CLUBS, DIAMONDS, HEARTS, SPADES};
</example>
<p>С его помощью создается целочисленный тип набором из четырех названий мастей, именующих целочисленные константы. Перечислимые константы - это идентификаторы CLUBS, DIAMONDS, HEARTS и SPADES, имеющие значения - 0, 1, 2 и 3, соответственно. Эти значения присвоены по умолчанию. Первой перечислимой константе присваивают постоянное целое численное значение 0. Каждый последующий член списка на единицу больше, чем его сосед слева. Переменным типа Suit, определенного пользователем, может быть присвоено только одно из четырех значений, объявленных в перечислении</p>
<p>Другой популярный пример перечислимого типа:</p>
<example>enum Months {JAN = 1, FEB, MAR, APR, MAY, YUN, YUL AUG, SEP, OCT, NOV, DEC};</example>
<p>Это объявление создает определенный пользователем тип Months с константами перечисления, представляющими месяцы года. Поскольку первое значение приведенного перечисления установлено равным 1, оставшиеся значения увеличиваются на 1 от 1 до 12. </p>
<p>В объявлении перечислимого типа любой константе перечисления можно присвоить целое значение.</p>

<tip start="Примечание"><b>Типичная ошибка.</b> После того, как константа перечисления определена, попытка присвоить ей другое значение является синтаксической ошибкой.</tip>


<h3>Основные моменты использования перечислений.</h3>

<p>1. Использование перечислений вместо целых констант облегчает чтение программы.</p>
<p>2. Идентификаторы в enum должны быть уникальными, но отдельные константы перечисления могут иметь одинаковые целые значения.</p>
<p>3. Набор идентификаторов перечислимого типа — собственный уникальный тип, отличающийся от других целочисленных типов.</p>
<p>4. Перечислимые константы могут определяться и инициализироваться произвольными целочисленными константами, а также константными выражениями:</p>
<example>enum ages (milton = 47, ira, harold = 56, philip = harold + 7};</example>
<tip start="Примечание">Обратите внимание на то, что когда нет явного инициализатора, применяется правило по умолчанию, таким образом - ira = 48. Кроме того, значения перечислимых констант могут быть не уникальными.</tip>

<p>5. Каждое перечисление является отдельным типом. Типом элемента перечисления является само перечисление. Например, в</p>
<example>enum Keyword {ASM, AUTO, BREAK};</example>
<p>AUTO имеет тип Keyword.</p>

<p>6. Перечислимая константа может быть объявлена анонимно, то есть без имени типа.</p>
<example>
enum {FALSE, TRUE};
enum {lazy, hazy, crazy} why;
</example>
<p>Первое объявление — распространенный способ объявления мнемонических целочисленных констант. Второе объявление объявляет переменную перечислимого типа why, с допустимыми значениями этой переменной lazy,hazy и crazy.</p>

<p>7. Перечисления могут неявно преобразовываться в обычные целочисленные типы, но не наоборот.</p>

<example>
enum boolean {FALSE, TRUE} q;  
enum signal {off, on} a = on;  //а инициализируется в on  
enum answer {no, yes, maybe = -1} b;   

int i, j = true;  //верно true преобразуется в 1 
 
a = off;  //верно  

і = а;  //верно i становится 1  

q = а;  //неверно два различных типа  

q = (boolean)а;  //верно явное преобразование приведением 
 
</example>

</lesson>