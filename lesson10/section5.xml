<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №10" next="hometask.xml" prev="section4.xml" summ="1">
<h2>Сортировка вставками.</h2>

<p>Сортировка простыми вставками в чем-то похожа на методы изложенные в предыдущих разделах урока. Аналогичным образом делаются проходы по части массива, и аналогичным же образом в его начале "вырастает" отсортированная последовательность.</p>

<p>Однако в сортировке пузырьком или выбором можно было четко заявить, что на i-м шаге элементы a[0]...a[i] стоят на правильных местах и никуда более не переместятся. Здесь же подобное утверждение будет более слабым: последовательность a[0]...a[i] упорядочена. При этом по ходу алгоритма в нее будут вставляться все новые элементы.</p>

<p>Будем разбирать алгоритм, рассматривая его действия на i-м шаге. Как говорилось выше, последовательность к этому моменту разделена на две части: готовую a[0]...a[i] и неупорядоченную a[i+1]...a[n]. На следующем, (i+1)-м каждом шаге алгоритма берем a[i+1] и вставляем на нужное место в готовую часть массива. Поиск подходящего места для очередного элемента входной последовательности осуществляется путем последовательных сравнений с элементом, стоящим перед ним. В зависимости от результата сравнения элемент либо остается на текущем месте(вставка завершена), либо они меняются местами и процесс повторяется. </p>
<center><img src="images\5.gif" ></img></center>

<p>Таким образом, в процессе вставки мы "просеиваем" элемент x к началу массива, останавливаясь в случае, когда найден элемент, меньший x или достигнуто начало последовательности.</p>

<h3>Реализация метода</h3>
<example>
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

template &lt;class T&gt;
void insertSort(T a[], long size) {
	T x;
	long i, j;

	for(i=0;i&lt;size;i++){  // цикл проходов, i - номер прохода
		x=a[i];
		
		// поиск места элемента в готовой последовательности 
		for (j=i-1;j&gt;=0&amp;&amp;a[j]&gt;x;j--)
				a[j+1]=a[j];  	// сдвигаем элемент направо, пока не дошли

		// место найдено, вставить элемент
		a[j+1] = x;
	}
}

void main(){
	srand(time(NULL));
	const long SIZE=10;
	int ar[SIZE];
	
	// до сортировки
	for(int i=0;i&lt;SIZE;i++){
		ar[i]=rand()%100;
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	shakerSort(ar,SIZE);

	// после сортировки
	for(int i=0;i&lt;SIZE;i++){
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
}
</example>

<h3>Принципы метода</h3>

<p>Хорошим показателем сортировки является весьма естественное поведение: почти отсортированный массив будет досортирован очень быстро. Это, вкупе с устойчивостью алгоритма, делает метод хорошим выбором в соответствующих ситуациях. Однако, алгоритм можно слегка улучшить. Заметим, что на каждом шаге внутреннего цикла проверяются 2 условия. Можно объединить из в одно, поставив в начало массива специальный "сторожевой элемент". Он должен быть заведомо меньше всех остальных элементов массива.</p> 
<center><img src="images\6.gif" ></img></center>

<p>Тогда при j=0 будет заведомо верно a[0] &lt;=x. Цикл остановится на нулевом элементе, что и было целью условия j&gt;=0.
Таким образом, сортировка будет происходить правильным образом, а во внутреннем цикле станет на одно сравнение меньше. Однако, отсортированный массив будет не полон, так как из него исчезло первое число. Для окончания сортировки это число следует вернуть назад, а затем вставить в отсортированную последовательность a[1]...a[n].</p>
<center><img src="images\7.gif" ></img></center>

<example>

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

template &lt;class T&gt;
void setMin(T a[],long size){
	T min=a[0];
	for(int i=1;i&lt;size;i++)
		if(a[i]&lt;min)
			min=a[i];
	a[0]=min;	
}

template &lt;class T&gt;
void insertSortGuarded(T a[], long size) {
	T x;
	long i, j;
	T backup = a[0];			// сохранить старый первый элемент
	setMin(a,size);				// заменить на минимальный

	// отсортировать массив
	for(i=1;i&lt;size;i++){  	
		x = a[i];

		for (j=i-1;a[j]&gt;x;j--)
			a[j+1]=a[j];

		a[j+1] = x;
	}

	// вставить backup на правильное место
	for(j=1;j&lt;size&amp;&amp;a[j]&lt;backup;j++)
		a[j-1]=a[j];

	// вставка элемента 
	a[j-1] = backup;
}

void main(){
	srand(time(NULL));
	const long SIZE=10;
	int ar[SIZE];
	
	// до сортировки
	for(int i=0;i&lt;SIZE;i++){
		ar[i]=rand()%100;
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	insertSortGuarded(ar,SIZE);

	// после сортировки
	for(int i=0;i&lt;SIZE;i++){
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
}

</example>




</lesson>
