<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №10" next="section4.xml" prev="section2.xml" summ="0">
<h2>Сортировка выбором.</h2>

<p>Идея данного метода состоит в том, чтобы создавать отсортированную последовательность путем присоединения к ней одного элемента за другим в правильном порядке.</p>

<p>Сейчас, мы с вами попробуем построить готовую последовательность, начиная с левого конца массива. Алгоритм состоит из n последовательных шагов, начиная от нулевого и заканчивая (n-1). На i-м шаге выбираем наименьший из элементов a[i] ... a[n] и меняем его местами с a[i]. Последовательность шагов при n=5 изображена на рисунке ниже.</p>
<center><img src="images\1.gif" ></img></center>
<p>Вне зависимости от номера текущего шага i, последовательность a[0]...a[i] является упорядоченной. Таким образом, на шаге (n-1) вся последовательность, кроме a[n] оказывается отсортированной, а a[n] стоит на последнем месте по праву: все меньшие элементы уже ушли влево. Рассмотрим пример, реализующий данный метод:</p>

<example>

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
using namespace std;
template &lt;class T&gt;
void selectSort(T a[], long size) {
    long i, j, k; 
	T x;

	for(i=0;i&lt;size;i++) {   	// i - номер текущего шага
		k=i;
		x=a[i];

		for(j=i+1;j&lt;size;j++)	// цикл выбора наименьшего элемента
			if(a[j]&lt;x){
				k=j;
				x=a[j];	        // k - индекс наименьшего элемента
			}
		a[k]=a[i];
		a[i]=x;   	// меняем местами наименьший с a[i]
	}
}

void main(){
	srand(time(NULL));
	const long SIZE=10;
	int ar[SIZE];
	
	// до сортировки
	for(int i=0;i&lt;SIZE;i++){
		ar[i]=rand()%100;
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	selectSort(ar,SIZE);

	// после сортировки
	for(int i=0;i&lt;SIZE;i++){
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
}
</example>

<h3>Основные принципы метода</h3>
<p>1. Для нахождения наименьшего элемента из n+1 рассматримаемых алгоритм совершает n сравнений. Таким образом, так как число обменов всегда будет меньше числа сравнений, время сортировки возрастает относительно количества элементов.</p>

<p>2. Алгоритм не использует дополнительной памяти: все операции происходят "на месте".</p>

<p> Давайте, определим, насколько устойчив данный метод? Рассмотрим последовательность из трех элементов, каждый из которых имеет два поля, а сортировка идет по первому из них. Результат ее сортировки можно увидеть уже после шага 0, так как больше обменов не будет. Порядок ключей 2a, 2b был изменен на 2b, 2a.</p>
<center><img src="images\2.gif" ></img></center> 
<p>Таким образом, входная последовательность почти упорядочена, то сравнений будет столько же, значит алгоритм ведет себя не очень оптимально. Однако, такую сортировку можно использовать для массивов имеющих небольшие размеры.</p>
</lesson>