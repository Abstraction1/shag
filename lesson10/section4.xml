<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №10" next="section5.xml" prev="section3.xml" summ="1">
<h2>"Пузырьковая" cортировка. </h2>
<p>
Идея метода состоит в следующем: шаг сортировки заключается в проходе снизу вверх по массиву. По пути просматриваются пары соседних элементов. Если элементы некоторой пары находятся в неправильном порядке, то меняем их местами. Для реализации расположим массив сверху вниз, от нулевого элемента - к последнему. После нулевого прохода по массиву "вверху" оказывается самый "легкий" элемент - отсюда аналогия с пузырьком. Следующий проход делается до второго сверху элемента, таким образом второй по величине элемент поднимается на правильную позицию.
</p>
<center><img src="images\3.gif" ></img></center>
Делаем проходы по все уменьшающейся нижней части массива до тех пор, пока в ней не останется только один элемент. На этом сортировка заканчивается, так как последовательность упорядочена по возрастанию.
<center><img src="images\4.gif" ></img></center>

<h3>Пример кода.</h3>
<example>
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
using namespace std;
template &lt;class T&gt;
void bubbleSort(T a[], long size){
    long i, j;
	T x;
	for(i=0;i&lt;size;i++){            // i - номер прохода
		for(j=size-1;j&gt;i;j--){     // внутренний цикл прохода
			if(a[j-1]&gt;a[j]){
				x=a[j-1];
				a[j-1]=a[j];
				a[j]=x;
			}
		}
	}
}

void main(){
	srand(time(NULL));
	const long SIZE=10;
	int ar[SIZE];
	
	// до сортировки
	for(int i=0;i&lt;SIZE;i++){
		ar[i]=rand()%100;
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	bubbleSort(ar,SIZE);

	// после сортировки
	for(int i=0;i&lt;SIZE;i++){
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
}
</example>

<h3>Основные принципы метода.</h3>

<p>Среднее число сравнений и обменов имеют квадратичный порядок роста, отсюда можно заключить, что алгоритм пузырька очень медленен и малоэффективен. Тем не менее, у него есть громадный плюс: он прост и его можно по-всякому улучшать. Чем мы сейчас и займемся.</p>

<p>Рассмотрим ситуацию, когда на каком-либо из проходов не произошло ни одного обмена. Это значит, что все пары расположены в правильном порядке, так что массив уже отсортирован. И продолжать процесс не имеет смысла. Таким образом первый шаг оптимизации заключается в запоминании, производился ли на данном проходе какой-либо обмен. Если нет - алгоритм заканчивает работу.</p>

<p>Процесс оптимизации можно продолжить, запоминая не только сам факт обмена, но и индекс последнего обмена k. Действительно: все пары соседих элементов с индексами, меньшими k, уже расположены в нужном порядке. Дальнейшие проходы можно заканчивать на индексе k, вместо того чтобы двигаться до установленной заранее верхней границы i.</p>

<p>Качественно другое улучшение алгоритма можно получить из следующего наблюдения. Хотя "легкий" пузырек снизу поднимется наверх за один проход, "тяжелые" пузырьки опускаются со минимальной скоростью: один шаг за итерацию. Так что массив 2 3 4 5 6 1 будет отсортирован за 1 проход, а сортировка последовательности 6 1 2 3 4 5 потребует 5 проходов.</p>

<p>Чтобы избежать подобного эффекта, можно менять направление следующих один за другим проходов. Получившийся алгоритм иногда называют "шейкер-сортировкой".</p>
<example>
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
using namespace std;
template &lt;class T&gt;
void shakerSort(T a[], long size) {
  long j, k=size-1;
  long lb=1, ub=size-1; // границы неотсортированной части массива
  T x;

  do{
      // проход снизу вверх 
	for(j=ub;j&gt;0;j--){
		if(a[j-1]&gt;a[j]){
			x=a[j-1];
			a[j-1]=a[j];
			a[j]=x;
			k=j;
		}
	}
    lb = k+1;

    // проход сверху вниз 
    for(j=1;j&lt;=ub;j++){
		if(a[j-1]&gt;a[j]){
			x=a[j-1];
			a[j-1]=a[j];
			a[j]=x;
			k=j;
		}
    }
    ub=k-1;

  }while (lb&lt;ub);
}

void main(){
	srand(time(NULL));
	const long SIZE=10;
	int ar[SIZE];
	
	// до сортировки
	for(int i=0;i&lt;SIZE;i++){
		ar[i]=rand()%100;
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	shakerSort(ar,SIZE);

	// после сортировки
	for(int i=0;i&lt;SIZE;i++){
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
}
</example>

<p>Таким образом, мы выяснили, что можем оптимизировать сортировку "пузырьком" на свой вкус. Дерзайте!!!</p>


</lesson>
