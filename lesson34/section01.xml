<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №34" next="section02.xml" prev="index.xml" summ="1">
<h2>Преобразование типов в стиле С++. </h2>
<p>
Для начала напомним, что оператор приведения типов позволяет компилятору преобразовывать один тип данных в другой. И язык программирования С, и язык программирования С++ поддерживают такую форму записи приведения типа:
</p>

<example>

(тип) выражение

Например,

double d;
d=(double) 10/3;

</example>


<h3>Операторы приведения типа в языке С++.</h3>

<p>
Кроме стандартной формы в стиле С, язык С++ поддерживает дополнительные операторы приведения типа:
</p>

<p><b><i>const_cast</i></b></p>
<example>

const_cast&lt;тип&gt; (объект)
</example>
<p><b><i>dynamic_cast</i></b></p>
<example>

dynamic_cast&lt;тип&gt; (объект)
</example>

<p><b><i>reinterpret_cast</i></b></p>
<example>

reinterpret_cast&lt;тип&gt;(объект) 
</example>

<p><b><i>static_cast</i></b></p>
<example>

static_cast&lt;тип&gt; (объект)
</example>

<p>
Рассмотрим данные конструкции более детально:
</p>

<p>
<b><i>const_cast</i></b> используется для явного переопределения модификаторов const и/или volatile. Новый тип должен совпадать с исходным типом, за исключением изменения его атрибутов const или volatile. Чаще всего оператор const_cast используется для снятия атрибута const. 
</p>
<p>
<b><i>dynamic_cast</i></b> проверяет законность выполнения заданной операции приведения типа. Если такую операцию выполнить нельзя, то выражение устанавливается равным нулю. Этот оператор в основном используется для полиморфных типов. Например, если даны два полиморфных класса, B и D, причем класс D выведен из класса B, то оператор <b><i>dynamic_cast</i></b> всегда может преобразовать указатель D* в указатель B*. Оператор <b><i>dynamic_cast</i></b> может преобразовать указатель B* в указатель D* только в том случае, если адресуемым объектом является объект D. И вообще, оператор <b><i>dynamic_cast</i></b> будет успешно выполнен только при условии, что разрешено полиморфное приведение типов (т.е. если новый тип можно законно применять к типу объекта, который подвергается этой операции). Если операцию приведения типа выполнить нельзя, результат действия оператора <b><i>dynamic_cast</i></b> оценивается как нулевой.
</p>
<p>
<b><i>static_cast</i></b> выполняет неполиморфное приведение типов. Например, его можно использовать для приведения указателя на базовый класс к типу указателя на производный класс. Его можно также использовать для любого стандартного преобразования. При этом никакие проверки во время работы программы не выполняются.
</p>
<p>
<b><i>reinterpret_cast</i></b> переводит один тип в совершенно другой. Например, его можно использовать для перевода указателя в целый тип. Оператор <b><i>reinterpret_cast</i></b> следует использовать для перевода типов указателей, которые несовместимы по своей природе.
</p>
Однако, следует помнить, что только оператор <b><i>const_cast</i></b> может освободить от "обета постоянства", т.е. ни один из остальных операторов этой группы не может "снять" с оъекта атрибут const.
</lesson>