<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №34" next="section05.xml" prev="section02.xml" summ="0">
<h2>Класс <b><i>auto_ptr</i></b>.</h2>
 
<p>
В языке программирования С++ есть понятие, которое проявляется в следующем утверждении - <b><u>"выделение ресурса - это инициализация"</u></b>. Данное утверждение идеально используется при выделении абсолютно любого типа ресурсов. Это делает работу программы более надежной, особенно, если в ходе работы программы возможно возникновение исключений.
</p>

<p>
Например, программа открывает некий файл или выделяет фрагмент памяти. При завершении работы этой программы естественно необходимо закрыть файл или освободить память. Однако исключительная ситуация может проявиться еще до того, как будет выполнено одно из вышеописанных действий, в результате чего действие так и не выполнится. 
</p>

<example>

void f(){

	FILE*f;

	if (!(f = fopen("test.txt", "rt")))
	{
		//не удалось открыть файл - выходим
		exit(0);
	}   
	//удалось, работаем с файлом дальше
	//но, здесь может возникнуть исключение
	//и до следующей строки мы не доберемся
	//соответственно файл не будет закрыт
	fclose(f);

}

</example>

<p>
Решением данной проблемы является следующий набор действий:
</p>
<ol>
<li>
Создать класс.</li><li>
Реализовать конструктор, в котором будет открываться файл.</li><li>
Реализовать деструктор, в котором файл будет закрываться.</li><li>
Для начала работы с файлом необходимо создать объект этого класса. (Файл будет автоматически открыт в конструкторе). </li></ol>
<p>
А, теперь главное - 
</p>
<p><b>
В случае возникновения исключительной ситуации при работе программы объект будет естественно уничтожен, но при этом для него будет вызван его деструктор, который и закроет файл (освободив память). Если же, программа завершится коректно, то и в этом случае вам не придется думать о явном закрытии файла, так как созданный объект будет автоматически уничтожен при выходе из области видимости и файл будет закрыт опять таки деструктором класса.
</b></p>

<example>

class FileOpen
{
	
	FILE* f;

public:

	FileOpen(char* filename, char* mode)
	{
		if (!(f = fopen(filename, mode)))
		{
			exit(0);
		}
	}

	~FileOpen(){
		fclose(f);
	}

};

void f(){

	FileOpen MyFile("test.txt", "r+");

	//здесь выполняем нужную работу с файлом  

}

</example>

<p>
Для усовершенствования нашего принципа мы можем использовать класс <b><i>auto_ptr</i></b>  (automatic pointer - автоматический указатель). Данный класс предоставляется стандартной библиотекой С++ и предназначен для работы с объектами, которые обычно необходимо удалять явно (например, объекты, созданные динамически с помощью оператора new). 
</p>
<p>
для создания объекта класса <b><i>auto_ptr</i></b> параметром конструктора должен быть указатель на объект, созданный динамически. Дальше c <b><i>auto_ptr</i></b> можно работать почти как с обычным указателем, который указывает на тот же динамический объект, на который указывал исходный указатель. Нам не нужно думать о явном удалении объекта, он будет автоматически удален деструктором класса <b><i>auto_ptr</i></b>. 
</p>
<p>
Синтаксис класса <b><i>auto_ptr</i></b> в стандартной библиотеке выглядит так: 
</p>

<example>

template&lt;class X&gt;

class Std::auto_ptr
{
	X* ptr;

public:

	//конструктор и деструктор

	explicit auto_ptr(X* p = 0)throw()
	{

		ptr = p;

	}

	~auto_ptr() throw()
	{
		
		delete ptr;

	} 
 	//оператор разыменования позволяет получить объект

	X&amp; operator*()const throw()
	{

		return *ptr;

	} 
       	//оператор -> позволяет получить указатель

	X* operator->()const throw()
	{

		return ptr;

	}

};

</example>


</lesson>