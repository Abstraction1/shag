<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №21" next="section02.xml" prev="index.xml" summ="1">
<h2>Перегруженные конструкторы.</h2>
<p>В прошлом уроке вы познакомились с основами ООП - и узнали о понятии класса. Сегодня мы с вами продолжим это приятное знакомство. Мы уже выяснили, конструкторы могут иметь параметры. Для этого просто нужно добавить эти параметры в объявление и определение конструктора, а затем, при создании объекта, задать их в качестве аргументов. Теперь к нашим знаниям добавим еще одно - конструкторов может быть несколько. Рассмотрим пример:</p> 
<example>

# include &lt;iostream&gt;
using namespace std;

class _3D 
{
 	double x, y, z;
	public:
	_3D ();
 	_3D (double initX, double initY, double initZ);
};

//конструктор класса _3D с параметрами
_3D::_3D(double initX, double initY, double initZ)
{
 	x = initX;
	y = initY;
 	z = initZ;
 	cout &lt;&lt; "\nWhis arguments!!!\n"; 
}

//конструктор класса _3D без параметров
_3D::_3D()
{
	x=y=z=0;
 	cout &lt;&lt; "\nNo arguments!!!\n"; 
}


void main()
{
	//создается объект A, вызывается
	//конструктор без параметров
	//все члены класса инициализируются нулем
	//на экране надпись "No arguments!!!"
	_3D A;  
 
 	//создается объект B, вызывается
	//конструктор c параметрами
	//все члены класса инициализируются 
	//соответствующими переменными
	//на экране надпись "Whis arguments!!!"
 	_3D B (3,4,0); 
}
</example>

<tip start="Примечание">Кстати!!! В отличие от конструктора, деструктор не может быть перегружен, так как не имеет параметров. Это вполне логично, поскольку отсутствует механизм передачи параметров удаляемому объекту.</tip>

<h5>Комментарии к примеру и особенности использования.</h5>
<p>1. Каждому способу объявления объекта класса должна соответствовать своя версия конструкторов класса. Если это не будет обеспечено, то при компиляции программы обнаружится ошибка на этапе компиляции.</p>

<p>2. На этом примере легко понять, чем может быть вызвана необходимость перегрузки конструкторов.(именно перегрузки, поскольку речь здесь идет о функциях, имеющих одинаковые имена, но различные списки параметров) Итак, главный смысл перегрузки конструкторов состоит в том, чтобы предоставить программисту наиболее подходящий метод инициализации объекта.
</p>

<p>3. В примере представлен наиболее распространенный вариант перегрузки конструкторов, т.е. конструктор без параметров и конструктор с параметрами. Как правило, в программе бывают необходимы оба эти вида, поскольку конструктор с параметрами более удобен при работе с одиночными объектами, но не может использоваться при инициализации объектов-элементов динамического массива.
</p>
<p>4. Хотя конструктор можно перегружать столько раз, сколько захотите, лучше не стоит этим злоупотреблять. Конструктор стоит перегружать лишь для наиболее часто встречающихся ситуаций.
</p>

<h5>Полезная информация.</h5>
<p>
Обратите внимание на то, что тела конструкторов описаны за пределами класса. В класс помещены только прототипы. Данная форма записи может быть использована и для обычных методов класса. Напомним, что в примерах прошлого урока тела методов описывались прямо в определении класса.
</p>
<p> Как лучше и грамотнее, спросите вы?! Способ из прошлого урока используется для простых и коротких методов, которые в дальнейшем не предполагается изменять. Так поступают отчасти из-за того, что описания классов помещают обычно в файлы заголовков, включаемые затем в прикладную программу с помощью директивы #include. Кроме того, при этом способе машинные инструкции, генерируемые компилятором при обращении к этим функциям, непосредственно вставляются в оттранслированный текст. Это снижает затраты на их исполнение, поскольку выполнение таких методов не связано с вызовом функций и механизмом возврата, увеличивая в свою очередь размер исполняемого кода (то есть такие методы становятся inline или встраиваемыми).
</p>
<p>
Cпособ, используемый в описанном выше примере, предпочтительнее для сложных методов. Объявленные таким образом функции автоматически заменяются компилятором на вызовы подпрограмм.
</p>



</lesson>
