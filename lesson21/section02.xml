<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №21" next="section03.xml" prev="section01.xml" summ="1">
<h2>Указатели на объекты.</h2>
<p>
До сих пор доступ к членам объекта осуществлялся, c использованием операции ".". Это правильно, если вы работаете с объектом. Однако доступ к членам объекта можно осуществлять и через указатель на объект. В этом случае обычно применяется операция стрелка "->". Похоже на структуру, не правда ли?
</p>

<p>
Указатель на объект объявляется точно так же, как и указатель на переменную любого типа. А, для получения адреса объекта, перед ним необходим оператор &amp;.
</p>
<example>
# include &lt;iostream&gt;
using namespace std;

class _3D 
{
 	double x, y, z;
public:
	_3D ();
 	_3D (double initX, double initY, double initZ);
	void Show(){
		cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;z&lt;&lt;"\n";
	}
};

// конструктор класса _3D с параметрами
_3D::_3D(double initX, double initY, double initZ)
{
 	x = initX;
	y = initY;
 	z = initZ;
 	cout &lt;&lt; "\nWhis arguments!!!\n"; 
}

// конструктор класса _3D без параметров
_3D::_3D()
{
	x=y=z=0;
 	cout &lt;&lt; "\nNo arguments!!!\n"; 
}



void main()
{
	// создается объект A, вызывается
	// конструктор c параметрами
	// все члены класса инициализируются 
	// соответствующими переменными
	// на экране надпись "Whis arguments!!!"
 	_3D A (3,4,0);

	// создается указатель на объект типа
	// _3D и в этот указатель записывается
	// адрес объекта А 
	_3D*PA=&amp;A;

	// через указатель вызывается функция
	// Show()
	PA->Show();
}
</example>
<h5>Динамическое выделение памяти под объект.</h5>

<p>

Если класс имеет конструктор без аргументов, то обращение к операции new полностью совпадает с тем, что используется для выделения памяти под обычные типы данных без инициализирующего выражения. 

</p>

<example>
# include &lt;iostream&gt;
using namespace std;

class Point 
{
 	double x, y;
public:
	Point(){
		x=y=0;
	 	cout &lt;&lt; "\nNo arguments!!!\n"; 		
	}
 	void Show(){
		cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;"\n";
	}
};

void main()
{
	// создание объекта
	Point A;
	// показ содержимого на экран
	A.Show();

	cout&lt;&lt;"****************************";
	// создание указателя на объект
	Point*PA;

	// Динамическое выделение памяти под один
	// объект типа Point
	PA=new Point;

	// проверка, выделилась ли память
	// и выход, если не выделилась
	if(!PA) exit(0);

	// через указатель вызывается функция
	// Show()
	PA->Show();

	cout&lt;&lt;"****************************";
	// создание указателя на объект
	Point*PB;

	// Динамическое выделение памяти под массив
	// объектов типа Point
	PB=new Point[10];
	
	// проверка, выделилась ли память
	// и выход, если не выделилась
	if(!PВ) exit(0);

	// Вызов функции Show() для каждого элемента
	// массива PB 
	for(int i=0;i&lt;10;i++){
		PB[0].Show();		
	}
	
	// Удаление объекта РА
	delete PA;

	// Удаление массива РB
	delete[]PB;	
	
}
</example>

<p>Если же конструктор класса имеет аргументы, то список аргументов помещается там же, где при работе со стандартными типами данных находится инициализирующее выражение.</p>

<example>
# include &lt;iostream&gt;
using namespace std;

class Point 
{
	double x, y;
public:
	// конструктор с параметрами
	// по умолчанию
	Point(double iX=1,double iY=1){
		x=iX;
		y=iY;
		cout &lt;&lt; "\nWhis arguments!!!\n"; 		
	}
	void Show(){
		cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;"\n";
	}
};

void main()
{
	// создание объекта
	Point A(2,3);
	// показ содержимого на экран
	A.Show();

	cout&lt;&lt;"****************************";
	// создание указателя на объект
	Point*PA;

	// Динамическое выделение памяти под один
	// объект типа Point
	// в круглых скобках - параметры для конструктора
	PA=new Point(4,5);

	// проверка, выделилась ли память
	// и выход, если не выделилась
	if(!PA) exit(0);

	// через указатель вызывается функция
	// Show()
	PA->Show();

	cout&lt;&lt;"****************************";
	// создание указателя на объект
	Point*PB;

	// Динамическое выделение памяти под массив
	// объектов типа Point
	// параметры не передаются 
	// используются параметры
	// конструктора по умолчанию
	PB=new Point[10];

	// проверка, выделилась ли память
	// и выход, если не выделилась
	if(!PB) exit(0);

	// Вызов функции Show() для каждого элемента
	// массива PB 
	for(int i=0;i&lt;10;i++){
		PB[0].Show();		
	}

	// Удаление объекта РА
	delete PA;

	// Удаление массива РB
	delete[]PB;	

}
</example>
<tip start="Примечание">Обратите внимания, что в данном примере использован конструктор с параметрами по умолчанию. Это связано с тем, что при динамическом выделении памяти под массив объектов НЕВОЗМОЖНО передать параметры в конструктор. В нашем примере мы этого и не делаем. Для массива объектов используются параметры по умолчанию. Эту проблему можно было решить иначе, создав конструктор без параметров.</tip> 
<h5>Статические массивы.</h5>
<p>
В отличие от динамики, при создании статического массива параметры в конструктор передать можно. Рассмотрим синтаксис этого действия на примере:
</p>
<example>
# include &lt;iostream&gt;
using namespace std;

class Point 
{
	double x, y;
public:
	//конструктор с параметрами
	Point(double iX,double iY){
		x=iX;
		y=iY;
		cout &lt;&lt; "\nWhis arguments!!!\n"; 		
	}
	void Show(){
		cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;"\n";
	}
};

void main()
{
	// создание массива объектов
	// передача параметров в конструктор
	Point AR[2]={Point(2,3),Point(4,5)};

	// Вызов функции Show() для каждого элемента
	// массива AR 
	for(int i=0;i&lt;2;i++){
		AR[i].Show();		
	}


}
</example>
</lesson>
