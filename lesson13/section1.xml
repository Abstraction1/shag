<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №13: Ссылки." next="section2.xml" prev="index.xml" summ="1">

<h2>Общие сведения о ссылках.</h2>
<p>С этого урока мы начнем рассматривать другой механизм передачи параметров, в частности, с использованием <b>ссылок</b>.
</p>
<p>Использование указателей в качестве альтернативного способа доступа к переменным таит в себе опасность - если был изменен адрес, хранящийся в указателе, то этот указатель больше не ссылается на нужное значение.
</p>

<p> Язык C предлагает альтернативу для более безопасного доступа к переменным через указатели.Объявив ссылочную переменную, можно создать объект, который, как указатель, ссылается на другое значение, но, в отличие от указателя, постоянно привязан к этому значению. Таким образом, <b>ссылка на значение <i>всегда</i> ссылается на это значение</b>.
</p>

<p>Ссылку можно объявить следующим образом:
<example>
&lt;имя типа&gt;&amp; &lt;имя ссылки&gt; = &lt;выражение&gt;;
                или
&lt;имя типа&gt;&amp; &lt;имя ссылки&gt;(&lt;выражение&gt;);
</example> 
</p>

<p>Раз ссылка является <b>другим именем уже существующего объекта</b>, то в качестве инициализирующего объекта должно выступать <b>имя некоторого объекта, уже расположенного в памяти</b>. Значением ссылки после выполнения соответствующего определения с инициализацией становится адрес этого объекта. Проиллюстрируем это на конкретном примере: 
</p>
<example>
#include "iostream"
using namespace std;
void main()
{
   int ivar = 1234;   //Переменной присвоено значение.
   int *iptr = &amp;ivar; //Указателю присвоен адрес ivar.
   int &amp;iref = ivar;  //Ссылка ассоциирована с ivar.
   int *p = &amp;iref;    //Указателю присвоен адрес iref.

   cout &lt;&lt; "ivar = " &lt;&lt; ivar &lt;&lt; "\n";
   cout &lt;&lt; "*iptr = " &lt;&lt; *iptr &lt;&lt;"\n";
   cout &lt;&lt; "iref = " &lt;&lt; iref &lt;&lt; "\n";
   cout &lt;&lt; "*p = " &lt;&lt; *p &lt;&lt; "\n";
}
</example>


<p>Результат работы программы:
   <example>
ivar = 1234
*iptr = 1234
iref = 1234
*p = 1234</example>
</p>
<p><b>Комментарии к программе.</b>Здесь объявляются четыре переменные. Переменная<b>ivar</b>  инициализирована значением 1234. Указателю на целое <b>*iptr</b> присвоен адрес<b>ivar</b>.  Переменная <b>iref</b> объявлена как ссылочная. Эта переменная в качестве своего значения принимает адрес расположения в памяти переменной <b>ivar</b>. Оператор:
<example>
cout &lt;&lt; "iref = " &lt;&lt; iref &lt;&lt; "\n";</example> выводит на экран значение переменной <b>ivar</b>. Это объясняется тем, что <b>iref</b> - <b><i>ссылка</i></b> на местоположение <b>ivar</b> в памяти.
</p>


<p>Последнее объявление <b>int *p = &amp;iref;</b> создает еще один указатель, которому присваивается адрес, хранящийся в <b>iref</b>. Строки:
<example>
int *iptr = &amp;ivar; 
          и
int *p = &amp;iref;</example>дают одинаковый результат. В них создаются указатели, ссылающиеся на <b>ivar</b>. На рис.1 проиллюстрирована взаимосвязь переменных из приведенной программы: 
</p>

<center><img src="images\ris47_1.jpg"></img></center>
<p>При использовании ссылок следует помнить одно правило: <b>однажды инициализировав ссылку ей нельзя присвоить другое значение!</b> Все эти конструкции:
<example>
a) int iv = 3;        b) iref++;     c) iref = 4321;
   iref = iv;
</example>приведут к изменению переменной <b>ivar</b>! 
</p>
<hr/>
<p> <b>Замечания</b>. 
<ul><li>1. В отличие от указателей, которые могут быть объявлены неинициализированными или установлены в нуль <b>(NULL)</b>, ссылки <b>всегда ссылаются на объект</b>. Для ссылок не существует аналога нулевого указателя.</li> 
<li>2. Ссылки нельзя инициализировать в следующих случаях:</li>
    <ul>
    <li>при использовании в качестве параметров функции. </li>
    <li>при использовании в качестве типа возвращаемого значения функции.</li>
    <li>в объявлениях классов.</li></ul>
<li>3. Не существует операторов, непосредственно производящих действия над ссылками!</li></ul> 
</p>

</lesson>
