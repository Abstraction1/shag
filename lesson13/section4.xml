<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №13:Ccылки" next="hometask.xml" prev="section3.xml" summ="1">
<h2>Операторы выделения памяти new и delete. </h2>
<h3>Операция выделения памяти new</h3> 
<p>С помощью вышеозначенной операции мы можем себе позволить выделять память динамически - т. е. на этапе выполнения программы.</p>
<p>Часто выражение, содержащее операцию new, имеет следующий вид:</p>
<example>указатель_на_тип_= new имя_типа (инициализатор) </example>						<p><b>Инициализатор</b> - это необязательное инициализирующее выражение, которое может использоваться для всех типов, кроме массивов.</p>		  
<p>При выполнении оператора </p>
<example>int *ip = new int;</example>
<p>создаются 2 объекта: динамический безымянный объект и указатель на него с именем ip, значением которого является адрес динамического объекта. Можно создать и другой указатель на тот же динамический объект: </p>
<example>int *other=ip; </example>
<center><img src="images\1.gif"></img></center>

<p>Если указателю ip присвоить другое значение, то можно потерять доступ к динамическому объекту: </p>
<example>
int *ip=new (int); 
int i=0; 
ip=&amp;i; 
</example>
<center><img src="images\2.gif"></img></center>
<p>В результате динамический объект по-прежнему будет существовать, но обратится к нему уже нельзя. Такие объекты называются мусором. </p>
<p>При выделении памяти объект можно инициализировать: </p>
<example>int *ip = new int(3);</example> 
<p>Можно динамически распределить память и под массив: </p>
<example>double *mas = new double [50]; </example>
<center><img src="images\3.gif"></img></center>
<p>Далее с этой динамически выделенной памятью можно работать как с обычным массивом: </p>
<example>
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
using namespace std;
void main(){
	srand(time(NULL));
	int size;
	int * dar;
	// запрос размера массива с клавиатуры
	cout&lt;&lt;"Enter size:\n";
	cin&gt;&gt;size;
	//выделение памяти под массив с количеством элементов size
	dar=new int [size];
	if(!dar){
		cout&lt;&lt;"Sorry, error!!!";
		exit(0);// функция организует выход из программы
	}
	// заполнение массива и показ на экран
	for(int i=0;i&lt;size;i++){
		dar[i]=rand()%100;
		cout&lt;&lt;dar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
}
</example>
<p>В случае успешного завершения операция new возвращает указатель со значением, отличным от нуля.</p>
<p>Результат операции, равный 0, т.е. нулевому указателю <b>NULL</b>, говорит о том, что не найден непрерывный свободный фрагмент памяти нужного размера.</p>
<h3>Операция освобождения памяти delete </h3>
<p>Операция <b>delete</b> освобождает для дальнейшего использования в программе участок памяти, ранее выделенной операцией <b>new</b>:</p>
<example>
delete ip; // Удаляет динамический объект типа int, 
              // если было ip = new int; 
delete [ ] mas; // удаляет динамический массив длиной 50, если было 
                  // double *mas = new double[50]; 
</example>
<p>Совершенно безопасно применять операцию к указателю <b>NULL</b>. Результат же повторного применения операции delete к одному и тому же указателю не определен. Обычно происходит ошибка, приводящая к зацикливанию. </p>
<p>Чтобы избежать подобных ошибок, можно применять следующую конструкцию:</p>
<example>
int *ip=new int[500]; 
 . . . 
if (ip){
	delete ip; ip=NULL;
} 
 else
 { 
	cout &lt;&lt;" память уже освобождена \n";
 } 

</example>
<p>
В наш, вышеописанный пример, мы теперь можем добавить освобождение памяти.
</p>
<example>
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
using namespace std;
void main(){
	srand(time(NULL));
	int size;
	int * dar;
	// запрос размера массива с клавиатуры
	cout&lt;&lt;"Enter size:\n";
	cin&gt;&gt;size;
	//выделение памяти под массив с количеством элементов size
	dar=new int [size];
	if(!dar){
		cout&lt;&lt;"Sorry, error!!!";
		exit(0);// функция организует выход из программы
	}
	// заполнение массива и показ на экран
	for(int i=0;i&lt;size;i++){
		dar[i]=rand()%100;
		cout&lt;&lt;dar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	// освобождение памяти
	delete[]dar;
}
</example>
</lesson>
