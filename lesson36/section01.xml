<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №36" next="section02.xml" prev="index.xml" summ="1">
<h2>Использование функторов. </h2>
<p>
Как вам известно из прошлых уроков, в библиотеке STL существует понятие функторов. Сейчас мы познакомимся с этим понятием поближе.
</p>
<p>
Функторы (иначе говоря, функциональные объекты) - это специализированный вид классов, которые включают в себя перегруженный оператор вызова функции. Как правило, функтор можно применить везде, где требуется функция. Проще говоря, когда должна быть вызвана функция, вызывается перегруженный оператор вызова функции.(оператор "круглые скобки").
</p>
<p>
Основным отличием функтора от обычной функции, является возможность хранения некоторого значения по принципу статических переменных. Принцип работы таков:
</p>

<p><i>
Первое обращение к функтору возбуждает вызов конструктора, который инициализирует сам функтор. При использовании обычной функции приходится хитрить, чтобы выполнить начальную инициализацию. Кроме того, некоторые источники говорят о том, что вызов функтора выполняется гораздо быстрее, чем вызов обычной функции с помощью указателя.
</i></p>

<p>
Рассмотрим пример, который позволит нам более детально разобраться в назначении функторов. Реализуем таблицу умножения. Требования следующие: первый множитель увеличивается слева направо, второй - сверху вниз. Это классический пример на алгоритм итерации.
</p>

<p>
Разберем алгоритм выполнения задания:
</p>


<ul>

<li>
Генерация строки с набором частных для одного числа и повторение генерации для нескольких чисел.
	<ul> 
		<li>Инициализация контейнера-списка (или вектора).</li>
		<li>Заполнение контейнера-списка (или вектора).</li>
		<li>Вывод значений контейнера-списка (или вектора)на экран.</li>
	</ul>
</li>
<li>
 Создание функтора, который должен последовательно генерирует число, начиная от заданного, и каждый раз увеличивает его на определенное значение.
</li>
</ul>

<example>
// библиотека для работы алгоритмов
// мы  еще будем рассматривать её более подробно сегодня 
#include &lt;algorithm&gt; 
#include &lt;iostream&gt;
// библиотека контейнера списка
#include &lt;list&gt;
using namespace std;

/*
Функциональный объект, содержащий два поля:
1. для хранения значения приращения (delta) 
2. для текущего значения генерируемого числа (current)
*/
class addNumberFrom
{
    int delta;
	int current;
/*
Конструктор класса инициализирует значение приращения и текущее значение.
Последнее может быть опущено, и тогда оно будет считаться равным 0
*/
public:
	addNumberFrom(int number, int from = 0):delta(number), current(from) {}

/*
Основа функтора - перегруженный оператор вызова функции 
- прибавляет значение приращения к текущему генерируемому числу
*/

	int operator()()
	{ 
		return current += delta; 
	}
};

// Вывод заголовка для таблицы умножения.

void main()
{
	cout&lt;&lt;"TABLE:"&lt;&lt;"\n\n";
	cout &lt;&lt; "----------" &lt;&lt;"\n\n";

	

	for(int i=1; i&lt;=10; i++)
	{
		// Cоздание контейнера-списка.
		list&lt;int&gt; l(10);

		/*
		Вызов алгоритма generate_n. Естественно, сам он не может ничего генерировать,
		однако последовательно перебирает значения, диапазон которых задан
		начальным итератором и количеством элементов списка. 
		Для записи числа в каждое значение вызывается функция,
		на которую ссылается третий параметр:
		*/

		generate_n(l.begin(), l.size(), addNumberFrom(i));

		/*
		Но мы вместо функции подставляем перегруженный оператор
		вызова функции - объект addNumberFrom. Если вызов происходит
		впервые, то вызывается конструктор объекта. Он инициализирует поле delta значением переменной i,
		а поле current - значением по умолчанию второго параметра конструктора, т. е. 0.

		Таким образом, контейнер-список заполняется произведениями числа
		в переменной i и множителями от 1 до 10. В алгоритме generate_n используется
		метод size(), который возвращает количество элементов в списке.
		Если имеются начальный и конечные итераторы,
		тогда лучше воспользоваться алгоритмом generate.
		*/

		// Собственно показ числа из контейнера-списка

		copy(l.begin(), l.end(), ostream_iterator&lt;int&gt;(cout,"\t"));
	}
}
</example>

<p>
Надеемся, пример помог вам понять функторы более глубоко. Теперь отметим, что зачастую различные арифметические и логические операции, а также операции сравнения могут реализовываться стандартными средствами STL, то есть набором уже существующих, встроенных функторов:
</p>

<ul> 

<li>
	Арифметические функторы
	<ul>
	<li>plus сложение x + y</li>
	<li>additition вычитание x - y</li>
	<li>times умножение x х y</li>
	<li>divides деление x / y</li>
	<li>modulus взятие остатка x % y</li>
	<li>negate  обращение знака - x</li>
	</ul>
</li>
<li>
	Функторы сравнения
	<ul> 
	<li>equal_to равно x == y</li>
	<li>not_equal_to не равно x != y</li>
	<li>greater больше x &gt; y</li>
	<li>less меньше x &lt; y</li>
	<li>greater_equal больше или равно x =&gt; y</li>
	<li>less_equal меньше или равно x &lt;= y</li>
	</ul>
</li>
<li>
	Логические функторы
	<ul>
	<li>logical_and логическое "и" x &amp;&amp; y</li>
	<li>logical_or логическое "или" x || y</li>
	<li>logical_not логическое "не" ! x</li>
	</ul>
</li>
</ul>


</lesson>