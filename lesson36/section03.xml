<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №36" next="section04.xml" prev="section02.xml" summ="1">
<h2>Использование алгоритмов.</h2>

<p>
Как вы уже наслышаны, в библиотеке STL существуют функции, которые выполняют различные стандартные действия. Действия эти, например, - поиск, преобразование, сортировка, копирование и так далее. Эти функции называются алгоритмами. В качестве параметрами для алгоритмов принято использовать итераторы. 
</p>

<p> 
Следует отметить, что алгоритму абсолютно всё равно, какого типа итератор, ему передали. Самое главное, чтобы этот итератор попадал в определенную группу. Например, если параметром алгоритма должен быть однонаправленный итератор, то передаваемый итератор должен быть либо однонаправленным, либо двунаправленным, или же итератором произвольного доступа.
</p>

<h5>Основная информация об алгоритмах.</h5>

<p>
Все алгоритмы делятся на две группы: те, которые изменяют данные, и те, которые их не изменяют.
</p>

<p>
Каждый алгоритм представляет собой шаблон функции или набор шаблонов функций. То есть, любой алгоритм может работать с абсолютно разными контейнерами.
</p>

<p>
Алгоритмы, возвращающие итератор, обычно, для сообщения о неудаче используют конец входной последовательности.
</p>

<p>
Алгоритмы не выполняют проверки диапазона на их входе и выходе.
</p>

<p>
Если алгоритм возвращает итератор, это будет итератор того же типа, что был на входе в алгоритм.
</p>

<p>
Алгоритмы определены в заголовочном файле &lt;algorithm&gt;. 
</p>

<p>
Приведем наиболее используемые алгоритмы библиотеки STL.
</p>

<ol>
			<li>
				Немодифицирующие операции.
				<ul>
				<li>for_earch() - выполняет операции для каждого элемента 
				последовательности</li>
				<li>find() - находит первое вхождение значения в последовательность</li>
				<li>find_if() - находит первое соответствие предикату в последовательности</li>
				<li>count() - подсчитывает количество вхождений значения в 
				последовательность</li>
				<li>count_if() - подсчитывает количество выполнений предиката в 
				последовательности</li>
				<li>search() - находит первое вхождение последовательности как 
				подпоследовательности</li>
				<li>search_n()- находит n-е вхождение значения в последовательность</li>
				</ul>	
			</li>

			<li>
				
				Модифицирующие операции.
				<ul>
				<li>copy() - копирует последовательность, начиная с первого элемента</li>
				<li>swap() - меняет местами два элемента</li>
				<li>replace() - заменяет элементы с указанным значением</li>
				<li>replace_if() - заменяет элементы при выполнении предиката</li>
				<li>replace_copy() - копирует последовательность, заменяя элементы с 
				указанным значением</li>
				<li>replace_copy_if() - копирует последовательность, заменяя элементы при 
				выполнении предиката</li>
				<li>fill() - заменяет все элементы данным значением</li>
				<li>remove() - удаляет элементы с данным значением</li>
				<li>remove_if() - удаляет элементы при выполнении предиката</li>
				<li>remove_copy() - копирует последовательность, удаляя элементы с 
				указанным значением</li>
				<li>remove_copy_if() - копирует последовательность, удаляя элементы при 
				выполнении предиката</li>
				<li>reverse() - меняет порядок следования элементов на обратный</li>
				<li>random_shuffle() - перемещает элементы согласно случайному 
				равномерному распределению ("тасует" последовательность)</li>
				<li>transform() - выполняет заданную операцию над каждым элементом 
				последовательности</li>
				<li>unique() - удаляет равные соседние элементы</li>
				<li>unique_copy() - копирует последовательность, удаляя равные соседние элементы</li>
				</ul>	
			</li>

			<li>
				
				Сортировка.
				<ul>
				<li>sort() - сортирует последовательность с хорошей средней эффективностью</li>
				<li>partial_sort() - сортирует часть последовательности</li>
				<li>stable_sort() - сортирует последовательность, сохраняя порядок 
				следования равных элементов</li>
				<li>lower_bound() - находит первое вхождение значения в отсортированной 
				последовательности</li>
				<li>upper_bound() - находит первый элемент, больший чем заданное значение</li>
				<li>binary_search() - определяет, есть ли данный элемент в отсортированной 
				последовательности</li>
				<li>merge() - сливает две отсортированные последовательности</li>
				</ul>	
			</li>

			<li>

				Работа с множествами.
				<ul>
				<li>includes() - проверка на вхождение</li>
				<li>set_union() - объединение множеств</li>
				<li>set_intersection() - пересечение множеств</li>
				<li>set_difference() - разность множеств</li>
				</ul>	
			</li>
			<li>
				Минимумы и максимумы.
				<ul>
				<li>min() - меньшее из двух</li>
				<li>max() - большее из двух</li>
				<li>min_element() - наименьшее значение в последовательности</li>
				<li>max_element() - наибольшее значение в последовательности</li>
				</ul>	
			</li>
			<li>
				Перестановки.
				<ul>
				<li>next_permutation() - следующая перестановка в лексикографическом 
				порядке</li>
				<li>prev_permutation() - предыдущая перестановка в лексикографическом 
				порядке</li>
				</ul>	
			</li>
			
</ol>

</lesson>