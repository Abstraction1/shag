<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №36" next="section03.xml" prev="section01.xml" summ="1">
<h2>Использование предикатов.</h2>

<p> И снова STL... Еще одно понятие, которое мы с Вами не рассматривали детально - предикаты.</p>

<p>
Зачастую, вам могут понадобиться специальные средства, которые принимают решения в зависимости от ситуации и координируют выполнение какой-либо вашей программы. Обычно для этих целей мы используем логические выражения языка программирования. Однако, в STL принято решать данную проблему иным способом. А именно, создавать предикаты.
</p>
<p>
<b>
Предикат - специальная функция, которая возвращает логическое значение (true либо false).
</b>
</p>

<p>
Наверное, вы уже догадались, что создать предикат достаточно легко - нужно просто написать функцию которая возвращает тип bool. Рассмотрим пример. Попробуем создать  предикат, определяющий четность числа. Если число окажется четным, предикат будет возвращать true. Используем следующий порядок действий:
</p>

<ul>
<li>Четность определяется получением остатка от деления на 2.</li>
<li>Затем, заполняется контейнер-список значениями от 1 до 10. (для этого вызывается метод push_back(), который добавляет значение в конец списка)</li>
<li>Затем значения выводятся на экран.</li>
<li>Далее осуществляется поиск и выделение всех четных значений. </li>
</ul>

<tip start="Примечание">
Эту задачу решает алгоритм remove_if. Обратите внимания, что многие алгоритмы, оканчивающиеся на _if, в качестве последнего параметра используют предикаты. Алгоритм remove_if сдвигает все подходящие значения в начало контейнера и возвращает итератор, который указывает на элемент, следующий за удаляемыми значениями. По этой причине, мы будем считать, что начиная с адреса, на который ссылается возвращаемый итератор, и до конца области данных контейнера располагаются неудаленные значения, для которых предикат вернул false. Здесь, в нашем примере, мы используем данную особенность следующим образом: все четные значения выводятся на экран (для этого мы копируем их в поток вывода, передав потоковому итератору пару итераторов, которые описывают область удаленных значений.)
</tip>

<example>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

// предикат
bool isEven(int num)
{
  return bool(num % 2); 
}

void main()
{
    list&lt;int&gt; l;
	list&lt;int&gt;::iterator t;

    for(int i=1; i&lt;=10; i++)
        l.push_back(i);

	copy(l.begin(), l.end(), ostream_iterator&lt;int&gt;(cout," "));
	cout&lt;&lt;"\n\n";
	t=remove_if(l.begin(), l.end(), isEven);
	copy(l.begin(), t, ostream_iterator&lt;int&gt;(cout," "));
}
</example>

</lesson>