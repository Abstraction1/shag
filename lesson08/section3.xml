<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №8" next="section4.xml" prev="section2.xml" summ="0">
<h2>Передача аргументов. Прототипы функций.</h2>

<h3>Передача аргументов по значению.</h3>
<p>
Поговорим, о том, что происходит в оперативной памяти. Аргументы, которые  указываются при определении функции, называются <b>формальными</b>. Это связанно с тем что, они создаются в момент вызова функции в оперативной памяти. При выходе из функции такие параметры будут уничтожены. Поэтому, если в другой функции программы будут параметры с тем же именем, то конфликта не будет. Рассмотрим, один из способов передачи аргументов:
</p>
<h3>Пример работы формальных параметров при передаче данных по значению.</h3>
<example>
#include &lt;iostream&gt;
using namespaсe std;

// Должна менять значения переменных местами
void Change(int One, int Two){
	cout&lt;&lt;One&lt;&lt;" "&lt;&lt;Two&lt;&lt;"\n\n";// 1 2
	int temp=One;
	One=Two;
	Two=temp;	
	cout&lt;&lt;One&lt;&lt;" "&lt;&lt;Two&lt;&lt;"\n\n";// 2 1
}
void main(){

	int a=1,b=2;
	cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;"\n\n"; // 1 2
	// передача по значению
	Change(a,b);
	cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;"\n\n"; // 1 2
	

}
</example>
<p>
1. В функцию передаются не a и b, а их точные копии. 
</p>
<p>
2. Все изменения происходят с копиями (One и Two), при этом сами a и b остаются неизменными.
</p>
<p>
3. При выходе из функции временные копии уничтожаются.
</p>
<p>
Исходя из вышеописанного - пока будьте внимательны при обработке значений внутри функции. В последствие, мы научимся решать данную проблему.
</p>

<tip start="Примечание"> Кстати, с массивами такого не случается. Все изменения происходящие с массивом в функции - сохраняются при выходе из неё.</tip>
<h5>Кое-что о массивах...</h5>
<p>Некоторую особенность имеет использование массивов в качестве аргументов. Эта особенность заключается в том, что имя массива преобразуется к указателю на его первый элемент, т.е. при передаче массива происходит передача указателя. По этой причине вызываемая функция не может отличить, относится ли передаваемый ей указатель к началу массива или к одному единственному объекту. При передаче одномерного массива достаточно просто указать пустые квадратные скобки:</p>
<example>
int summa (int array[ ], int size){ 
     int res=0; 
     for (int i = 0; i &lt; size; i++) 
	res+ = array[i]; 
     return res; 
} 
</example>
<p>Если в функцию передаётся двумерный массив, то описание соответствующего аргумента функции должно содержать количество столбцов; количество строк - несущественно, поскольку, как говорилось ранее в функцию фактически передаётся указатель. </p>
<example>
int summa (int array[ ][5], int size_row, int size_col){ 
     int res=0; 
     for (int i = 0; i &lt; size_row; i++) 
	 for (int j = 0; j &lt; size_col; j++)
		res+ = array[i][j]; 
     return res; 
} 
</example>
<h3>Прототипы функций или второй способ объявления.</h3>
<p>При втором способе объявления функции необходимо сообщить компилятору о том, что функция существует. Для этого до main предоставляется имя функции, ее аргументы, а также тип возвращаемого значения. Такую конструкцию называют прототипом функции. Когда компилятор встречает прототип функции он точно знает о том, что функция существует в программе после main - и, она должна там быть.
</p>
<example>
библиотеки
возвращаемое_значение имя_функции(аргументы);
void main(){
	тело main;
}
возвращаемое_значение имя_функции(аргументы){
	тело функции;
}
</example>

<example>
#include &lt;iostream&gt;
using namespaсe std;
// прототипы
void MyFunc();
void MyFuncNext();

void main(){
	MyFunc(); 	//MyFunc
	MyFuncNext();	//MyFuncNext
}
//описания
void MyFunc(){
	cout&lt;&lt;"MyFunc\n";
}
void MyFuncNext(){
	cout&lt;&lt;"MyFuncNext\n";
}
</example>
<p><strong>Считается, что такое объявление функции является наиболее красивым и правильным.</strong></p>



</lesson>