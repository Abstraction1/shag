<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №25" next="hometask.xml" prev="section02.xml" summ="0">
<h2>Функции с произвольным количеством и типом аргументов.</h2>

<p>
Данный раздел урока посвящен изучению относительно нового типа функций, количество параметров у которых становится известным только в момент обращения к этой функции.
</p>
<p>
Итак, в языке C++ допустимы функции, у которых количество параметров и их типы при компиляции самой функции не определены. Эти значения становятся известными только в момент вызова функции, когда явно задан список фактических параметров. При определении и описании таких функций, имеющих списки параметров неизвестной длины, спецификация формальных параметров заканчивается многоточием. То есть, общий синтаксис таков: 
</p>
<example>

  тип_функции имя_функции (спецификация_явных_параметров,...); 
</example>
<p>
Здесь спецификация явных параметров - это список спецификаций отдельных параметров, количество и типы которых фиксированы и известны в момент компиляции. Эти параметры называются обязательными. После списка явных (обязательных) параметров ставится необязательная запятая, а затем многоточие, извещающее компилятор, что дальнейший контроль соответствия количества и типов параметров при обработке вызова функции проводить не нужно. 
</p>
<p>
Каждая функция с переменным списком параметров должна иметь механизм определения их количества и типов. Существует два подхода к решению этой задачи. 
</p>

<p>
1. Первый подход предполагает добавление в конец списка необязательных параметров специального параметра-индикатора с уникальным значением, которое будет сигнализировать об окончании списка. В теле функции параметры последовательно перебираются, и их значения сравниваются с заранее известным концевым признаком.
</p>
<p>
2. Второй подход предусматривает передачу в функцию значения реального количества фактических параметров. Эту величину  можно передавать в функцию с помощью одного из явно задаваемых (обязательных) параметров.
</p> 

<p>
Следует отметить, что, в обоих подходах - и при задании концевого признака, и при указании числа реально используемых фактических параметров - переход от одного фактического параметра к другому выполняется с помощью указателей, то есть с использованием адресной арифметики. Проиллюстрируем сказанное примерами. 
</p>

<h5>Пример 1. Составить программу вычисления суммы заданных целых чисел с использованием количества слагаемых.</h5>
<example>
#include &lt;iostream&gt;
using namespace std;
//Прототип функции.
long summa (int,...); 
void main()
{
	cout &lt;&lt; "\n summa(2,4,6)=" &lt;&lt; summa (2,4,6);

	cout &lt;&lt; "\n summa(6,1,2,3,4,5,6)="&lt;&lt; summa (6,1,2,3,4,5,6);

}
//Передаем количество параметров.
long summa (int k,...) 
{
	 //pk содержит адрес расположения 
	 //начала списка параметров.
	 //это связано с тем, что параметры
	 //располагаются по порядку
	 //в оперативной памяти
	int *pk=&amp;k; 

	//подсчет суммы
	//к - количество параметров
	long sm=0;
	for (;k;k--)
		  sm+=*(++pk);

	return sm;
}

</example>


<h5>Комментарии к программе.</h5>
<p>
В обычном случае при описании функции задается список переменных - набор формальных параметров, используя которые осуществляется доступ к переданным значениям. Здесь такого списка нет. Каким же образом получить доступ к перечню переданных параметров? Это осуществляется с помощью указателей: сначала в указатель помещается адрес конца или начала списка явных параметров, а затем, используя это значение, мы производим перемещение по переменному списку параметров. 
</p>

<hr/>

<h5>Пример 2. Перепишем программу, используя предопределенное значение (пусть это будет 0).</h5>

<example>
#include &lt;iostream&gt;
using namespace std;
// k - это теперь, всего лишь один
// из суммируемых параметров
long summa (int k,...)
{
	//начиная с k
	int *pk=&amp;k;
	long sm=0;
	//движемся до тех пор, 
	//пока не встретим значение 0
	while (*pk) 
		//подсчет суммы
		 sm+=*(pk++);
	return sm;
}
void main() 
{
	// тестируем
	cout &lt;&lt; "\n summa(4,6,0)="&lt;&lt; summa (4,6,0);
	cout &lt;&lt; "\n summa(1,2,3,4,5,6,0)="&lt;&lt; summa (1,2,3,4,5,6,0);
	cout &lt;&lt; "\n summa(1,2,0,4,5,6,0)="&lt;&lt; summa (1,2,0,4,5,6,0);
 }

Результат работы программы:

summa(4,6,0)=10
summa(1,2,3,4,5,6,0)=21

// Внимание здесь функция 
// доработает лишь до первого нуля
// остальные данные будут утеряны.
summa(1,2,0,4,5,6,0)=3
</example>

<tip start="Примечание">
Кстати, с подобными функциями вы уже знакомы - это printf и scanf.
</tip>
</lesson>