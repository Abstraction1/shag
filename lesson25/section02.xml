<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №25" next="section03.xml" prev="section01.xml" summ="1">
<h2>Понятие "умного" указателя (smart pointer) </h2>
<p>Начнем с того, что то, о чём мы с Вами сейчас будем говорить, реализуется с помощью перегрузки селектора. Итак.</p>
<hr/>
<p>
Умный указатель (англ. smart pointer) — класс, имитирующий интерфейс обычного указателя и добавляющий к нему некую новую функциональность, например проверку границ при доступе или очистку памяти.
</p>

<p>
Иначе говоря, умные указатели - это объекты, в которых хранится указатель на настоящий объект и, как правило, счётчик числа обращений к объекту.
</p> 

<p>
В классе также присутствует деструктор для настоящего объекта, который не вызывается извне, а только внутри smart pointer. Принцип таков, что, когда счётчик обращений к объекту равен 0, вызовется деструктор.
</p>

<p> 
Например, есть массив указателей на объекты. Вы  используете копию указателя на один объект где-нибудь ещё. Потом очищаете массив, удаляя при этом объекты, а "где-нибудь ещё" все ещё хранит указатель. Естественно, что, при доступе к нему происходит сбой программы, т.к. объект был удалён при очистке массива.
</p>

<p>
При наличии smart pointer, такого не произойдёт, т.к. при создании копии указателя внутренний счётчик увеличится на 1. Те будет равен двум - 1 для массива, и ещё 1 для копии. Теперь даже если мы удалим объект из массива, внутренний счётчик уменьшится на 1 и станет равным 1, т.е. копия может продолжать работать с объектом. После того как он станет ненужным, копия освобождает память от него и счётчик становится равным 0. Именно, в этот момент вызывается деструктор для оригинального объекта.
</p>

<p>
Ну что ж, всё сказано. Пора попробовать блюдо под названием "умный указатель" на вкус. :)))
</p>

<example>
#include &lt;iostream&gt;
using namespace std;
class Temp
{
	int TEMP;	
	public:
		//конструктор
		Temp(){TEMP=25;}
		//функция показа на экран
		void TempFunction(){
			cout&lt;&lt;"TEMP = "&lt;&lt;TEMP&lt;&lt;"\n\n";
		} 
		//функция установки значения
		void TempSet(int T){
			TEMP=T;
		}
};
// Класс, реализующий умный указатель
class SmartPointer 
{
	// Инкапсулированный указатель
	Temp*ptr;
	//счётчик копий 
	int count_copy;

public:
	//конструктор
	SmartPointer (Temp*p=NULL){
		//записываем 0 при создании копий нет
		count_copy=0;
		ptr=p;
	}
	// конструктор копирования
	SmartPointer (const SmartPointer&amp;obj){
		//создается копия - увеличиваем счётчик
		ptr=obj.ptr;
		count_copy++;		
	}
	//перегрузка оператора равно
	SmartPointer operator=(const SmartPointer&amp;obj){
		//создается копия - увеличиваем счётчик
		ptr=obj.ptr;
		ptr=obj.ptr;
		count_copy++;
		//возвращаем сам объект для ситуации a=b=c
		return *this;
	}
	// уничтожение объекта
	~SmartPointer(){
		//если объект есть и копий нет
		if(ptr!=NULL&amp;&amp;count_copy==0){
			cout&lt;&lt;"\n~Delete Object\n";
			//уничтожаем объект
			delete[]ptr;
		}
		//в противном случае(уничтожается копия)
		else{
			//уменьшаем счётчик
			count_copy--;
			cout&lt;&lt;"\n~Delete Copy\n";
		}
			
	} 
	//старая добрая перегрузка селектора
	Temp* operator->(){
		return ptr;
	}

};

void main(){
	//создаем объект
	Temp*main_ptr=new Temp;
	//инициализируем этим объектом умный указатель
	SmartPointer PTR(main_ptr);
	//проверяем работу умного указателя
	PTR->TempSet(100);
	PTR->TempFunction();
	// создаем копию (работа конструктора копирования)
	SmartPointer PTR2=PTR;
}

Результат работы программы:
// работа с объектом через умный указатель
TEMP = 100
//уничтожение копии
~Delete Copy
//уничтожение самого объекта
~Delete Object  
</example>   
</lesson>
