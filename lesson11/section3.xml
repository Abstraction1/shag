<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №11" next="section4.xml" prev="section2.xml" summ="0">
<h2>Быстрая сортировка.</h2>
<p>"Быстрая сортировка" - была разработана около 40 лет назад и является наиболее широко применяемым и в принципе самым эффективным алгоритмом. Метод основан на разделении массива на части. Общая схема такова: </p>

<p>1. Из массива выбирается некоторый опорный элемент a[i]. </p>
<p>2. Запускается функция разделения массива, которая перемещает все ключи, меньшие, либо равные a[i], слева от него, а все ключи, большие, либо равные a[i] - справа, теперь массив состоит из двух частей, причем элементы левой меньше элементов правой.</p>
 
<p>3. Если в подмассивасивах более двух элементов, рекурсивно запускаем для них ту же функцию.</p> 
<p>4. В конце получится полностью отсортированная последовательность.</p>

<p>Рассмотрим алгоритм более детально.</p>
<h3>Делим массив пополам.</h3>
<p>Входные данные: массив a[0]...a[N] и элемент p, по которому будет производиться разделение.</p>

<p>1. Введем два указателя: i и j. В начале алгоритма они указывают, соответственно, на левый и правый конец последовательности.</p> 
<p>2. Будем двигать указатель i с шагом в 1 элемент по направлению к концу массива, пока не будет найден элемент a[i] &gt;= p.</p>
<p>3. Затем аналогичным образом начнем двигать указатель j от конца массива к началу, пока не будет найден a[j] &lt;= p.</p> 
<p>4. Далее, если i &lt;= j, меняем a[i] и a[j] местами и продолжаем двигать i,j по тем же правилам.</p> 
<p>5. Повторяем шаг 3, пока i &lt;= j.</p>
<p>Рассмотрим рисунок, где опорный элемент p = a[3].</p>
<center><img src="images\1.gif" ></img></center>
<p>Массив разделился на две части: все элементы левой меньше либо равны p, все элементы правой - больше, либо равны p.</p>
<h3>Пример программы.</h3>
<example>
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

template &lt;class T&gt;

void quickSortR(T a[], long N) {
// На входе - массив a[], a[N] - его последний элемент.

  long i = 0, j = N; 		// поставить указатели на исходные места
  T temp, p;

  p = a[ N/2 ];		// центральный элемент

  // процедура разделения
  do {
    while ( a[i] &lt; p ) i++;
    while ( a[j] &gt; p ) j--;

    if (i &lt;= j){
      	temp = a[i];
	a[i] = a[j];
	a[j] = temp;
      	i++;
	j--;
    }

  }while ( i&lt;=j );


  // рекурсивные вызовы, если есть, что сортировать 
  if ( j &gt; 0 ) quickSortR(a, j);
  if ( N &gt; i ) quickSortR(a+i, N-i);
}

void main(){
	srand(time(NULL));
	const long SIZE=10;
	int ar[SIZE];
	
	// до сортировки
	for(int i=0;i&lt;SIZE;i++){
		ar[i]=rand()%100;
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	quickSortR(ar,SIZE-1);

	// после сортировки
	for(int i=0;i&lt;SIZE;i++){
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
}
</example> 
<h5>Алгоритм рекурсии.</h5>
<p>1. Выбрать опорный элемент p - середину массива</p>
<p>2. Разделить массив по этому элементу</p>
<p>3. Если подмассив слева от p содержит более одного элемента, вызвать quickSortR для него.</p>
<p>4. Если подмассив справа от p содержит более одного элемента, вызвать quickSortR для него.</p>


</lesson>