<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="”рок є11" next="hometask.xml" prev="section3.xml" summ="1">
<h2>ƒвоичный поиск.</h2>
<p>
¬ прошлом уроке мы рассмотрели алгоритм линейного поиска, однако это не единственна€ возможность организовать поиск в массиве. ≈сли у нас есть массив, содержащий упор€доченную последовательность данных, то, в данном случае, очень эффективен двоичный поиск.
</p>
<h3>“еори€ двоичного поиска.</h3>
<p>ѕредположим, что переменные Lb и Ub содержат, соответственно, левую и правую границы отрезка массива, где находитс€ нужный нам элемент. ѕоиск мы всегда будем начинать с анализа среднего элемента отрезка массива. ≈сли искомое значение меньше среднего элемента, мы переходим к  поиску в верхней половине отрезка, где все элементы меньше только что проверенного. ƒругими словами, значением Ub становитс€ (M (средний элемент) Ц 1) и на следующей итерации мы работаем с половиной массива. “аким образом, в результате каждой проверки мы вдвое сужаем область поиска. “ак, в нашем примере, после первой итерации область поиска Ц всего лишь три элемента, после второй остаетс€ всего лишь один элемент. “аким образом, если длина массива равна 6, нам достаточно трех итераций, чтобы найти нужное число.
</p>
<h3>ѕример реализации.</h3>
<example>

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

int BinarySearch (int A[], int Lb, int Ub, int Key)
{
	int M;
	while(1){
		M = (Lb + Ub)/2;
		if (Key &lt; A[M])
			Ub = M - 1;
		else if (Key &gt; A[M])
			Lb = M + 1;
		else
			return M;

		if (Lb &gt; Ub)
			return -1;
	}
} 



void main(){
	srand(time(NULL));
	const long SIZE=10;
	int ar[SIZE];
	int key,ind;
	
	// до сортировки
	for(int i=0;i&lt;SIZE;i++){
		ar[i]=rand()%100;
		cout&lt;&lt;ar[i]&lt;&lt;"\t";
	}
	cout&lt;&lt;"\n\n";
	cout&lt;&lt;"Enter any digit:";
	cin&gt;&gt;key;
	ind=BinarySearch(ar,0,SIZE,key);
	cout&lt;&lt;"Index - "&lt;&lt;ind&lt;&lt;"\t";	
	cout&lt;&lt;"\n\n";
}

</example>
<p>
ƒвоичный поиск - очень мощный метод. ѕосудите сами: например, длина массива равна 1023, после первого сравнени€ область сужаетс€ до 11 элементов, а после второй - до 255. Ћегко посчитать, что дл€ поиска в массиве из 1023 элементов достаточно 10 сравнений.
</p>



</lesson>
