<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №11" next="section3.xml" prev="section1.xml" summ="0">	  

<h2>Рекурсии или итерации?</h2>
<p>Изучив предыдущий раздел урока – вы наверняка задались вопросом: а зачем нужна рекурсия? Ведь, реализовать вычисление факториала можно и с помощью итераций и это совсем не сложно:</p>

<example>

#include &lt;iostream&gt;
using namespace std;

long int Fact2(long int N)
{
	long int F = 1;
	//цикл осуществляет подсчет факториала
	for (long int i=2; i&lt;=N; i++)
			F *= i;
	return F;
}



void main()
{
   long number=5;
   long result=Fact2(number);
   cout&lt;&lt;"Result "&lt;&lt;number&lt;&lt;"! is - "&lt;&lt;result&lt;&lt;"\n";
}

</example>
<p>
Такой алгоритм, наверное, будет более естественным для программистов. На самом деле, это не совсем так. С точки зрения теории, любой алгоритм, который можно реализовать рекурсивно, совершенно спокойно реализуется итеративно. Мы только что в этом убедились.
</p>
<p>
Однако это не совсем так. Рекурсия производит вычисления гораздо медленнее, чем итерация. Кроме того, рекурсия потребляет намного больше оперативной памяти в момент своей работы.
</p>
<p>
Значит ли это, что рекурсия бесполезна? Ни в коем случае!!! Существует ряд задач, для которых рекурсивное решение тонко и красиво, а итеративное – сложно, громоздко и неестественно. Ваша задача, в данном случае – научиться, не только оперировать рекурсией и итерацией, но и интуитивно выбирать, какой из подходов применять в конкретном случае. 
От себя можем сказать, что лучшее применение рекурсии – это решение задач, для которых свойственна следующая черта: решение задачи сводится к решению таких же задач, но меньшей размерности и, следовательно, гораздо легче разрешаемых.
</p>
<p>
Удачи Вам на данном поприще!!! Как говорится: «Что бы понять рекурсию, надо просто понять рекурсию».
</p>

</lesson>
