<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №31" next="section02.xml" prev="index.xml" summ="1">
<h2>Вложенный класс.</h2>
<p>
Здравствуйте!!! Сегодня мы будем знакомиться с различными видами взаимодействий классов между собой.(или, иначе говоря механизмами повторного использования) И, начнём мы с вами с самой простой темы - вложенные классы. Итак, для начала определение:
</p>
<p>
<b><i>
Вложенный (внутренний) класс (inner class) — это класс, полностью определённый внутри другого класса. И, если объект обычного класса, как правило существует самостоятельно, то объект вложенного класса должен быть привязан к объекту класса, в котором этот вложенный класс описан. Класс, в который вкладывается другой класс называют объемлющим.
</i></b>
</p>

<h4>Основные особенности работы с вложенным классом.</h4>

<p>
1. Вложенный класс является членом объемлющего класса, а его определение может находиться в любой из секций public, private или protected объемлющего класса.
</p>

<hr/>

<p>
2. Имя вложенного класса известно в области видимости объемлющего класса, но ни в каких других областях. Это означает, что оно не конфликтует с таким же именем, объявленным в объемлющей области видимости. Например, так:
</p>

<example>

//самостоятельный (глобальный) класс А
class A { /* ... */ }

class B {
public:

   // вложенный класс A инкапсулирован внутри области видимости класса B
   class A {...};

   // Здесь, используется вложенный класс A
   A*obj;
};

void main(){
	// вложенный А невидим в данной области видимости
	// поэтому здесь используется глобальный класс А
	А*obj2;
}

</example>

<hr/>

<p>3. Для вложенного класса допустимы такие же виды членов, как и для невложенного. Например:</p>

<example>

class A {

public:

   class B {
      friend class A;       // объявление друга
      B( int val=0 );       // конструктор
      B *next;              // указатель на собственный класс
      int value;
   };

private:

   B *obj;  

};

</example>

<hr/>

<p>
4. Напомним, что закрытым называется член, который доступен только в определениях членов и друзей класса. У объемлющего класса нет права доступа к закрытым членам вложенного. Чтобы в определениях членов A можно было обращаться к закрытым членам B, класс B объявляет A как друга. 
</p>

<p>
В продолжение прошлого утверждения, следует отметить, что вложенный класс также не имеет никаких специальных прав доступа к закрытым членам объемлющего класса. Если бы нужно было разрешить B доступ к закрытым членам класса A, то в объемлющем классе A следовало бы объявить вложенный класс как друга. В приведенном выше примере этого не сделано, поэтому B не может обращаться к закрытым членам A.
</p>
<hr/>
<p>
5. Объявление B открытым членом (в секции public) класса A означает, что вложенный класс можно использовать как тип во всей программе, в том числе и за пределами определений членов и друзей класса. Например:
</p>

<example>

void main(){
	A::B *ptr;
}

</example>

<p>
Этот приём дает широкую область видимости для вложенного класса. Однако, вложенный класс обычно реализуется только для личных нужд объемлющего класса и не должен быть доступен во всей программе. Поэтому лучше объявить вложенный класс B закрытым членом A, вот так:
</p>

<example>

class A {

public:
   // ...
private:
   class B {
      // ...
   };
   B *obj;  

};

</example>

<p>
Теперь тип B доступен только из определений членов и друзей класса A, поэтому все члены класса B можно сделать открытыми. При таком подходе объявление A как друга B становится ненужным. Вот новое определение класса A:
</p>

<example>

class A{

public:
   // ...
private:

   // Теперь B закрытый вложенный тип
   class B {
   // а его члены открыты
   public:
      B( int val=0 );
      B *next;
      int value;
   };

   B *obj;

};

</example>

<hr/>

<p>
6. Обратим внимание, что конструктор класса B (в прошлом примере) не задан как встроенный внутри определения класса и, следовательно, должен быть определен вне него. Открытым остается вопрос: "Где?". Конструктор класса B не является членом A и, значит, не может быть определен в теле последнего. Следовательно, его нужно определить в глобальной области видимости – той, которая содержит определение объемлющего класса. Отсюда, рождается правило:
</p>

<p><b>
Когда функция-член вложенного класса не определяется как встроенная в теле, она должна быть определена вне самого внешнего из объемлющих классов.
</b></p>

<p>
Вот как могло бы выглядеть определение конструктора B. Однако, показанный ниже синтаксис, в глобальной области видимости некорректен:
</p>

<example>
class A {
public:
  

private:

   class B {

   public:
      B( int val=0 );
      


   };
};

// ошибка: B вне области видимости
B:: B( int val ) { ... }

</example>

<p>
Вся проблема заключается в том, что имя B отсутствует в глобальной области видимости. При использовании его таким образом следует указывать, что B – вложенный класс в области видимости A. Это делается путем следующим образом:
</p>

<example>

// к имени вложенного класса мы обращаемся через имя объемлющего
// это происходит в глобальной области видимости
A::B::B( int val ) {
   value = val;
   next = 0;
}

</example>

<hr/>

<p>
7. Если бы внутри B был объявлен статический член, то его определение также следовало бы поместить в глобальную область видимости. Инициализация этого члена могла бы выглядеть так:
</p>

<example>
int A::B::static_mem = 1024;
</example>

<tip start="Примечание">
Обратите внимание, что функции-члены и статические данные-члены не обязаны быть открытыми членами вложенного класса для того, чтобы их можно было определить вне его тела. Закрытые члены B также определяются в глобальной области видимости.
</tip>

<hr/>

<p>
8. Вложенный класс разрешается определять вне тела объемлющего. Например, определение B могло бы находиться и в глобальной области видимости:
</p>

<example>

class A {

public:
   // ...
private:
   // здесь объявление необходимо
   class B;
   B *obj;
};

// имя вложенного класса отмечено именем объемлющего класса
class A::B {
public:
   B( int val=0 );
   B *next;
   int value;
};

</example>

<p>
В глобальном определении имя вложенного B должно быть отмечено именем объемлющего класса A. Заметьте, что объявление B в теле A опустить нельзя. Определение вложенного класса не может быть задано в глобальной области видимости, если предварительно оно не было объявлено членом объемлющего класса. Но при этом вложенный класс не обязательно должен быть открытым членом объемлющего.
</p>
<hr/>
<p>9. Пока компилятор не увидел определения вложенного класса, разрешается объявлять лишь указатели и ссылки на него. Объявления члена obj класса A (в примере выше) правильно несмотря на то, что B определен в глобальной области видимости, поскольку данный член – указатель. Если бы один из них был объектом, то его объявление в классе A привело бы к ошибке компиляции:
</p>

<example>

class A {

public:
   // ...

private:
   // объявление необходимо
   class B;
   B *obj;
   B x;   // ошибка: неопределенный вложенный класс B

};

</example>

<tip start="">
Зачем определять вложенный класс вне тела объемлющего? Возможно, он поддерживает некоторые детали реализации B, а нам нужно скрыть их от пользователей класса A. Поэтому мы помещаем определение вложенного класса в заголовочный файл, содержащий описание A. Таким образом, определение B может находиться лишь внутри исходного файла, включающего реализацию класса A и его членов.
</tip>
<hr/>

<p>
10. Вложенный класс можно сначала объявить, а затем определить в теле объемлющего. Это позволяет иметь во вложенных классах члены, ссылающиеся друг на друга:
</p>

<example>
class A {

public:
   // ...
private:

   // объявление A::B
   class B;

   class Ref {
      // pli имеет тип A::B*
      B *pli;
   };

   определение A::B
   class B {
      // pref имеет тип A::Ref*
      Ref *pref;
   };

};

</example>

<p>Если бы B не был объявлен перед определением класса Ref, то объявление члена pli было бы ошибкой.</p>
<hr/>

<p>11. Вложенный класс не может напрямую обращаться к нестатическим членам объемлющего, даже если они открыты. Любое такое обращение должно производиться через указатель, ссылку или объект объемлющего класса. Например:
</p>

<example>

class A {

public:
   int init( int );

private:

   class A::B {

   public:

      B( int val=0 );
      void mf( const A &amp; );
      int value;

   };
};

A::B::B { int val )
{

   // A::init() - нестатический член класса A
   // должен использоваться через объект или указатель на тип A

   value = init( val );   // ошибка: неверное использование init

};

</example>

<p>
При использовании нестатических членов класса компилятор должен иметь возможность идентифицировать объект, которому принадлежит такой член. Внутри функции-члена класса B указатель this неявно применяется лишь к его членам. Благодаря неявному this мы знаем, что член value относится к объекту, для которого вызван конструктор. Внутри конструктора B указатель this имеет тип B*. Для доступа же к функции-члену init() нужен объект типа A или указатель типа A*.
</p>

<p>
Следующая функция-член mf() является решением проблемы, так как обращается к init() с помощью параметра-ссылки. Таким образом, init() вызывается для объекта, переданного в аргументе функции:
</p>

<example>

void A::B::mf( A &amp; i1 ) {

	//обращается к init() по ссылке
   	memb = i1.init();   

}

</example>

<hr/>
<hr/>
<p>
В заключение следует отметить, вложенные классы, чаще всего, нужны для выполнения каких-то локальных задач в процессе работы основного класа. Поэтому, мы вам не советуем злоупотреблять ими. Возможно, в дальнейшем вам вдруг понадобиться использовать ваш класс в другом новом классе. И вместо того что бы просто создать объект прийдется всё писать заново. 
</p>
</lesson>