<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №31" next="section03.xml" prev="section01.xml" summ="1">
<h2>Агрегирование и композиция. </h2>
<p>
Сейчас мы с вами рассмотрим еще один механизм, который строит отношения между классами. Этот механизм широко используется во многих языковых технологиях, в том числе и С++. Называется он - агрегирование (или агрегация).
</p>
<p><b>
Агрегирование – это включение объекта (объектов) одного класса в состав объекта другого класса. 
</b></p>
<p>Сейчас мы приведем вам пример агрегации, и, вы будете приятно удивлены. Оказывается, вы делали такое раньше самостоятельно.</p>

<example>

#include &lt;iostream&gt;
using namespace std;

// класс "точка"
class Point{

	// кооординаты
	int X;
	int Y;
public:

	//конструктор
	Point(){
		X=Y=0;
	}

	//установка координат
	SetPoint(int iX,int iY){
		X=iX;
		Y=iY;
	}

	//демонстрация координат
	void Show(){
		cout&lt;&lt;"----------------------------\n\n";
		cout&lt;&lt;X&lt;&lt;"\t"&lt;&lt;Y&lt;&lt;"\n\n";
		cout&lt;&lt;"----------------------------\n\n";
	}
};
//класс фигура
class Figura{

	// агрегация точки
	// (координаты углов)
	Point*obj;

	// количество углов
	int count;
	// цвет фигуры
	int color;
	
	public:

	//конструктор
	Figura(){
		count=color=0;
		obj=NULL;
	}

	// создание фигуры
	void CreateFigura(int cr,int ct){
		// если углов меньше трех - это не фигура
		if(ct&lt;3) exit(0);
		//инициализация цвета и количества углов
		count=ct;
		color=cr;
		// выдделение памяти под массив точек
		obj=new Point[count];
		if(!obj) exit(0);

		//установка координат точек
		int tempX,tempY;
		for(int i=0;i&lt;count;i++){
			cout&lt;&lt;"Set X\n";
			cin&gt;&gt;tempX;
			cout&lt;&lt;"Set Y\n";
			cin&gt;&gt;tempY;
			obj[i].SetPoint(tempX,tempY);
		}
	}

	//показ фигуры
	void ShowFigura(){
		cout&lt;&lt;"----------------------------\n\n";
		cout&lt;&lt;"Color"&lt;&lt;color&lt;&lt;"\n\nPoints - "&lt;&lt;count&lt;&lt;"\n\n";
		for(int i=0;i&lt;count;i++){
			obj[i].Show();
		}	
	}

	//если фигура была очистить память
	~Figura(){
		if(obj!=NULL) delete[]obj;
	}


};

void main(){

	Figura f;
	f.CreateFigura(255,3);
	f.ShowFigura();

}

</example>

<p>Следует отметить, что кроме самой АГРЕГАЦИИ, существует еще частный ее случай под названием композиция. Дадим определение этому явлению:</p>

<p><b>Композиция - форма агрегации, при которой каждый агрегируемый объект сам может является агрегатом.</b></p>

<p>
Иначе говоря, если к нашему примеру мы добавим класс "рисунок", который будет аккумулировать в себе набор агрегатов-фигур, это и будет композиция.
</p>

<p>Композиция и агрегация достаточно сильный аппарат, который конкурирует по своей форме и стилю с предметом наших последующих дискуссий - наследованием. Плюсы и минусы того и другого мы рассмотрим позже в этом уроке.</p>
</lesson>
