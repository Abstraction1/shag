<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №24" next="section04.xml" prev="section02.xml" summ="0">
<h2>Дружественная перегрузка.</h2>
<p>
Итак, мы рассмотрели дружественные функции и несколько примеров их применения. Однако одним из основных свойств этих специфических функций является то, что с их помощью можно осуществить перегрузку операторов. Такой тип перегрузки носит название дружественной.
</p>

<p>
Проиллюстрируем особенности оформления операции-функции в виде дружественной функции класса.
</p>

<example>
#include &lt;iostream>
using namespace std;

// класс реализующий работу
// с логическим значением
class Flag
{  
	bool flag;
	// дружественная функция (перегрузка
	// оператора ! - замена значения флага
	// на противоположное)
	friend Flag&amp; operator !(Flag&amp;f);
 public:

	 // Конструктор.
	 Flag(bool iF)  
     {
		 flag = iF;
	 }
	 // Компонентная функция показа значения флага 
	 // в текстовом формате:
	 void display(){
		 if(flag) cout&lt;&lt;"\nTRUE\n";
		 else cout&lt;&lt;"\nFALSE\n";
	 }
};

// Определение дружественной
// операции-функции.
// (this не передается, поэтому 1 параметр)
Flag&amp; operator !(Flag &amp; f) 
{ 
	//замена значения на противоположное
	f.flag=!f.flag;
	return f;
}

void main()	
{ 
	Flag A(true);

	// показ начального значения
	A.display();

	// замена значения на противоположное
	// с помощью перегруженного оператора
	A=!A;
	// показ измененного значения
	A.display();
}

Результат выполнения программы: 

TRUE

FALSE

</example>

<h5>Глобальная перегрузка.</h5>

<p>
В C++ кроме двух известных вам разновидностей перегрузки (перегрузка в классе и дружественная перегрузка), существует еще одно понятие - глобальная перегрузка, осуществляемая во внешней области видимости. 
</p>
<p>
Допустим, переменные a и b объявлены как объекты класса C. В классе C определен оператор C::operator+(C), поэтому 
</p>

<example>

a+b означает a.operator+(b)
</example>

<p>
Однако, также возможна глобальная перегрузка оператора +:
</p>

<example>

C operator+(C,C) {....} 
</example>

<p>
Такой вариант перегрузки тоже применим к выражению a+b, где a и b передаются соответственно в первом и втором параметрах функции. Из этих двух форм предпочтительной считается перегрузка в классе. Т. к. вторая форма требует открытого обращения к членам класса, а это отрицательно отражается на строгой эстетике инкапсуляции. Вторая форма может быть более удобной для адаптации классов, которые находятся в библиотеках, где исходный текст невозможно изменить и перекомпилировать.То есть добавить в класс перегрузку в качестве метода класса нереально.
</p>

<p>
Смешивать эти две формы в программе не рекомендуется. Если для некоторого оператора определены обе формы с одинаковыми типами формальных параметров, то использование оператора может создать двусмысленность, которая, скорее всего, окажется фатальной.
</p>

<p> 
Тем не менее, глобальная перегрузка операторов обеспечивает симметрию, которая также обладает эстетической ценностью. Рассмотрим пример:
</p>

<example>
#include &lt;iostream&gt;
using namespace std;

// класс "точка"
class Point
{  
	 // координаты точки
	 int X;
	 int Y;
 public:

	 // конструктор
	 Point(int iX,int iY){
		 X=iX;
		 Y=iY;
	 }

	 //показ на экран
	 void Show(){
		cout&lt;&lt;"\n+++++++++++++++++++++\n";
		cout&lt;&lt;"X = "&lt;&lt;X&lt;&lt;"\tY = "&lt;&lt;Y;
		cout&lt;&lt;"\n+++++++++++++++++++++\n";
	 }

	 // перегруженный оператор +
	 // метод класса для ситуации Point+int
	 Point&amp;operator+(int d){
		 Point P(0,0);
		 P.X=X+d;
		 P.Y=Y+d;
		 return P;
	 }
	 // функции доступа к 
	 // privat-членам без них 
	 // глобальная перегрузка невозможна
	 int GetX() const{
		 return X;
	 }
	 int GetY() const{
		 return Y;
	 }
	 void SetX(int iX){
		 X=iX;
	 }
	 void SetY(int iY){
		 Y=iY;
	 }	
};

// глобальная перегрузка
// для ситуации int + Point
// доступ к private-членам
// через специальные функции
Point&amp;operator+(int d,Point&amp;Z){
		 Point P(0,0);
		 P.SetX(d+Z.GetX());
		 P.SetY(d+Z.GetY());
		 return P;
}

void main()	
{ 
	// создание объекта
    	Point A(3,2);
	A.Show();

	//оператор-метод +
	Point B=A+5;
	B.Show();

	//глобальный оператор 
	Point C=2+A;
	C.Show();
}

</example>
 

<p>
Без глобальной перегрузки задача int + Point не решается. Поскольку мы не можем получить доступ к "родному” целому типу (то есть к типу int) и переопределить его операции, обеспечить симметрию простым определением операторов класса не удастся. Потребуется решение с глобальными функциями. 
</p>
<tip start="Примечание">
Здесь мы могли бы применить дружественную перегрузку, и таким образом избавиться от "функций доступа к private-членам". Однако, если бы тело класса Point было бы для нас закрыто, то вписать в него функцию-друга было бы нереально.  
</tip>

<h3>Перегрузка ввода/вывода данных.</h3>

<p>
Для того, что бы закрепить новую полученную информацию о перегрузке рассмотрим возможность перегрузить операторы &lt;&lt; и &gt;&gt;. Для начала немного информации - 
</p>

<p>
<b>Выполнение любой программы С++ начинаются с набором предопределенных открытых потоков, объявленных как объекты классов  в файле-библиотеке iostream. Среди них есть два часто используемых нами объекта - это cin и cout.
</b>
</p>

<p>
<b>
cin - объект класса istream (Потоковый класс общего назначения для ввода, являющийся базовым классом для других потоков ввода)
</b>
</p>

<p>
<b>
cout - объект класса ostream (Потоковый класс общего назначения для вывода, являющийся базовым классом для других потоков вывода)
</b>
</p>

<p>
<b>
Вывод в поток выполняется с помощью операции, которая является перегруженной операцией сдвига влево &lt;&lt; . Левым ее операндом является объект потока вывода. Правым операндом может являться любая переменная, для которой определен вывод в поток. Например, оператор cout &lt;&lt; "Hello!\n"; приводит к выводу в предопределенный поток cout строки "Hello!". 
</b>
</p>

<p>
<b>
Для ввода информации из потока используется операция извлечения, которой является перегруженная операция сдвига вправо &gt;&gt;. Левым операндом операции &gt;&gt; является объект класса istream. 
</b>
</p>

<p>
Чтобы избежать неожиданностей, ввод-вывод для абстрактных типов данных должен следовать тем же соглашениям, которые используются операциями ввода и вывода для встроенных типов, а именно:  
</p>

<p>
1. Возвращаемым значением для операций ввода и вывода должна являться ссылка на поток, чтобы несколько операций могли быть выполнены в одном выражении.
</p>

<p>
2. Первым параметром функции должен быть поток, из которого будут извлекаться данные, вторым параметром - ссылка или указатель на объект определенного пользователем типа.
</p>

<p>
3. Чтобы разрешить доступ к закрытым данным класса, операции ввода и вывода должны быть объявлены как дружественные функции класса.
</p>

<p>
4. В операцию вывода необходимо передавать константную ссылку на объект класса, поскольку данная операция не должна модифицировать выводимые объекты.
</p>

<p>
Итак, рассмотрим пример подобной перегрузки:
</p>
<example>

#include &lt;iostream&gt;
using namespace std;

// класс "точка"
class Point
{  
	 // координаты точки
	 int X;
	 int Y;
 public:

	 // конструктор
	 Point(int iX,int iY){
		 X=iX;
		 Y=iY;
	 }
	// дружественные функции перегрузки ввода и вывода данных
	 friend istream&amp; operator&gt;&gt;(istream&amp; is, Point&amp; P); 
	 friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Point&amp; P);
	 
};
//ввод данных через поток
istream&amp; operator&gt;&gt;(istream&amp;is, Point&amp;P){
	cout&lt;&lt;"Set X\t";
	is &gt;&gt; P.X;
	cout&lt;&lt;"Set Y\t";
    	is &gt;&gt; P.Y; 
    	return is; 
}
//вывод данных через поток
ostream&amp; operator&lt;&lt;(ostream&amp;os, const Point&amp;P){
	os &lt;&lt; "X = " &lt;&lt; P.X &lt;&lt; '\t'; 
    	os &lt;&lt; "Y = " &lt;&lt; P.Y &lt;&lt; '\n'; 
    	return os; 
}

void main()	
{ 
	// создание объекта
    	Point A(0,0);

	// одиночный ввод и вывод
	cin&gt;&gt;A;
	cout&lt;&lt;A;

	// множественное выражение
	Point B(0,0);
	cin&gt;&gt;A&gt;&gt;B;
	cout&lt;&lt;A&lt;&lt;B;
}
</example>

<tip start="Примечание"> Кстати!!! В одном из примеров мы использовали константный метод - метод, который не имеет право изменять поля класса. Однако, если какое-то поле объявлено со спецификатором mutable, его значение МОЖНО менять в методе типа const.</tip>
</lesson>