<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №24" next="section03.xml" prev="section01.xml" summ="1">
<h2>Дружественные функции.</h2>

<p>
Дружественной функцией класса называется функция, которая, не являясь его компонентом, имеет доступ к его защищенным (private) и собственным (protected) компонентам. Функция не может стать другом класса "без его согласия". Для получения прав друга функция должна быть описана в теле класса со спецификатором friend. Именно при наличии такого описания класс предоставляет функции права доступа к защищенным и собственным компонентам. Например, так: 
</p>

<example>

#include &lt;iostream&gt;
using namespace std;

// Класс - прямоугольник 
class rect{    

	// ширина и высота
	int Width, Height; 
	//символ для отображения
	char Symb;
	// Прототип дружественной функции для замены символа:
	friend void friend_put(rect*r,char s);

  public:

	// Конструктор.
	rect(int wi, int hi, char si) 
	{ 
		Width = wi;
		Height = hi;
		Symb = si;
	}
	// Вывод фигуры на экран
	void display ()
	{
		cout&lt;&lt;"\n\n";
		for(int i=0;i&lt;Height;i++){
			for(int j=0;j&lt;Width;j++){
				cout&lt;&lt;Symb;
			}
			cout&lt;&lt;"\n\n";
		}
		cout&lt;&lt;"\n\n";
	}
};
// Дружественная функция замены 
// символа в конкретном объекте:
void friend_put(rect*r, char s)
{
	// обращение к закрытому члену здесь допустимо
	// т. к. функция "дружит" с классом
	r-&gt;Symb = s;
}
void main ()
{ 
	// Создание объектов
	rect A(5,3,'A');  
	rect B(3,5,'B');
	A.display ();
	B.display ();
	//замена символов с помощью
	//friend-функции
	friend_put(&amp;A,'a'); 
	friend_put(&amp;B,'b');
	A.display ();
	B.display ();
}
</example>

<h5>Комментарии к примеру.</h5>
<p>1. Функция friend_put описана в классе rect как дружественная и определена как обычная глобальная функция (вне класса, без указания его имени, без операции :: и без спецификатора friend).
</p>
<p>
2. Как дружественная она получает доступ к любым данным класса и изменяет значение символа того объекта, адрес которого будет передан ей как значение первого параметра. 
</p>
<p>
3. В функции main cоздаются два объекта A и B, для которых определяются размеры фигуры и символы для вывода. Затем фигуры показываются на экран.
</p>
<p>
4. Функция friend_put успешно заменяет символы объектов, что демонстрирует повторный вывод на экран. 
</p>

<h4>Некоторые особенности дружественных функций.</h4>

<p>
Теперь, когда мы познакомились с механизмом создания дружественных функций, остановимся на некоторых важных моментах. Все то, что мы сейчас вам расскажем, связано с тем фактом, что дружественная функция не является компонентом класса. Итак:
</p>

<p>1. Дружественная функция при вызове не получает указателя this.</p>
<p>2. Объекты классов должны передаваться дружественной функции только явно через аппарат параметров.</p>
<p>3. При вызове дружественной функции нельзя использовать операции выбора, а именно:</p> 
<example>

имя_объекта.имя_функции
        
указатель_на_объект  -> имя_функции
</example>

<p>
4.На дружественную функцию не распространяется действие спецификаторов доступа (public, protected, private), поэтому место размещения прототипа дружественной функции внутри определения класса безразлично.
</p>

<p>
5. Дружественная функция не может быть компонентной функцией того класса, по отношению к которому определяется как дружественная, зато она может быть просто глобальной функцией, а также компонентной функцией другого ранее определенного класса.
</p>

<p>
6. Дружественная функция может быть дружественной по отношению к нескольким классам.
</p>

<h3>Кое-что о применении.</h3>

<p>
Использование механизма дружественных функций позволяет упростить интерфейс между классами. Например, дружественная функция позволит получить доступ к собственным или защищенным компонентам сразу нескольких классов. Тем самым из классов можно иногда убрать компонентные функции, предназначенные только для доступа к этим "скрытым" компонентам.
</p>

<p>
В качестве примера рассмотрим дружественную функцию двух классов "точка на плоскости" и "прямая на плоскости".
</p>
<p>1. Класс "точка на плоскости" включает компонентные данные для задания координат (х, у) точки.</p>
<p>2. Компонентными данными класса "прямая на плоскости" будут коэффициенты A, B, C общего уравнения прямой A*х+B*y+C = 0.</p>
<p>3. Дружественная функция определяет уклонение заданной точки от заданной прямой. Если (a, b) - координаты конкретной точки, то для прямой, в уравнение которой входят коэффициенты A, B, C, уклонение вычисляется как значение выражения A*a+B*b+C.</p> 
<p>
В нижеописанной программе определены классы с общей дружественной функцией, в основной программе введены объекты этих классов и вычислено уклонение от точки до прямой:
</p>

<example>

#include &lt;iostream&gt;
using namespace std;

// Предварительное  упоминание о классе line_.
class  line_;	

// Класс  "точка на плоскости":
class point_
{
	// Координаты точки на плоскости.
		float x, y;
public:
		// Конструктор.
		point_(float xn = 0, float yn = 0)
		{
			x = xn;
			y = yn; 
		}
		friend float uclon(point_,line_);
};

// Класс "прямая на плоскости":
class line_
{	
	// Параметры прямой.
		float A, B, C;  	
public:
		// Конструктор.
		line_(float a, float b, float c) 
		{
			A = a;
			B = b;
			C = c;
		}
	    	friend float uclon(point_,line_);
};
// Внешнее определение дружественной функции.
float uclon(point_ p, line_ l)
{ 
	// вычисление отклонения прямой
	return l.A * p.x + l.B * p.y + l.C; 
}
void main()
{	
	// Определение точки P.
	point_ P(16.0,12.3);

	// Определение прямой L.
	line_ L(10.0,-42.3,24.0);

	cout &lt;&lt; "\n Result" &lt;&lt; uclon(P,L) &lt;&lt; "\n\n";
}
</example>

</lesson>
