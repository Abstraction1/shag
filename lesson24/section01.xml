<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №24" next="section02.xml" prev="index.xml" summ="1">
<h2>Еще раз о перегрузке...</h2>
<p>Сегодня мы с вами подводим итоги по перегрузке операторов. Поэтому в данном разделе мы остановимся на рассмотрении еще нескольких примеров.</p>

<h3>Оператор "круглые скобки".()</h3>

<p>
Оператор "круглые скобки" чаще всего используется, в тех ситуациях, когда нам необходимо дать пользователю класса возможность изменить содержимое объекта уже после того, как последний создан. То есть, с помощью данного оператора мы убираем из класса функции типа SetValue:
</p>

<example>
# include &lt;iostream&gt;
using namespace std;
class MyPoint{
	int X;
	int Y;
public:
	MyPoint(){
		X=0;
		Y=0;
	}

	// функция, которая используется для изменения
	// значений полей объекта уже после его создания
	// именно от нее мы будем избавляться с помощью
	// перегрузки круглых скобок
	void SetValue(int x,int y){
        	X=x;
		Y=y;
	}
	void Show(){
		cout&lt;&lt;X&lt;&lt;" "&lt;&lt;Y&lt;&lt;"\n\n";
	}
};
void main(){
	MyPoint P;
	P.Show();

	//изменение значений полей объекта
	P.SetValue(2,3);
	P.Show();
}
</example>

<p>
Как видите, приведенный пример класса достаточно прост. Упростим его еще больше :))). Для этого используем "круглые скобки" со следующим синтаксисом:
</p>

<example>

	Тип_Возвращаемого_Значения operator () (список_аргументов); 
</example>

<p>
Модифицируем код:
</p>

<example>
# include &lt;iostream&gt;
using namespace std;
class MyPoint{
	int X;
	int Y;
public:
	MyPoint(){
		X=0;
		Y=0;
	}

	// перегруженный оператор ()
	void operator()(int x,int y){
        	X=x;
		Y=y;
	}
	void Show(){
		cout&lt;&lt;X&lt;&lt;" "&lt;&lt;Y&lt;&lt;"\n\n";
	}
};
void main(){
	MyPoint P;
	P.Show();

	//изменение значений полей объекта
	P(2,3);
	P.Show();
}
</example>

<p>
Достаточно просто, не правда ли??? Однако всегда есть особенности которые вам необходимо запомнить:
</p>

<p>
1. В отличие от бинарных и унарных операторов, оператор вызова функции может принимать любое количество аргументов (от 0 и больше), другими словами количество параметров функции ограничивается только здравым смыслом.
</p>
<p>
2. Перегруженный оператор вызова функции не изменяет механизма вызова функции, он изменяет только то, как оператор интерпретируется при его применении к объекту данного класса.
</p>

<hr/>

<h3>Перегрузка операторов new, new[], delete, delete[]</h3>

<p>
Сразу следует отметить, что операции new и delete предопределены для любого типа, в том числе и для абстрактного типа, определенного через механизм классов. То есть создавать их перегрузку в классе не обязательно. Однако, бывает необходимо использовать для объекта какой-то необычный способ выделения памяти. Для этого new и delete можно перегрузить. Например, нужно выделять память и, в случае отсутствия её, создавать файл на диске, в который будет записываться информация. Осуществить такую перегрузку очень просто. Рассмотрим общий синтаксис:
</p>
<example>

Для выделения памяти под один объект и удаление её:

void* operator new(size_t размер){

     код оператора

     return указатель_на_память;

}
 
void operator delete(void* p){

     код оператора

}

Для выделения памяти под множество объектов и удаление её:

void* operator new[](size_t размер){

     код оператора

     return указатель_на_память;

}
 
void operator delete[](void* p){

     код оператора

}

</example>

<h5>Некоторые особенности.</h5>
<p>1. Параметр размер будет содержать число в байтах, которое необходимо выделить для размещения объекта. Это значение будет сформировано автоматически, т. е. передавать явно его нет необходимости.</p>
<p>2. У параметра размер тип данных size_t. Данный тип - это псевдоним, под которым скрывается unsigned int.</p>
<p>3. В прототипе оператора new можно указать дополнительные параметры, которые будут передаваться при вызове new. При этом - самое главное, чтобы на первом месте в обьявлении функции находился параметр типа size_t.</p>
<p>4. Перегруженная функция new должна возвращать указатель на выделенную память.</p>    
<p>5. Функция delete получает указатель на область памяти, которую необходимо освободить, при этом, она обязана освободить эту память.</p>
<p>6. В delete также можно передавать дополнительные параметры.</p>
<p>Ну, а теперь, рассмотрим пример:</p>
<example>

# include &lt;iostream>
using namespace std;
// библиотека для функций
// выделения памяти
#include &lt;malloc.h>

class SomeClass{
	int some;

public:
	// перегруженные операторы new и delete, 
	// здесь также используются дополнительные 
	// параметры, передаваемые внутрь операторов
	void * operator new(size_t size,char* str = "New");
	void   operator delete(void* ptr);

	// перегруженные операторы new [] и delete [] 
	void * operator new [] (size_t fullsize, char* str = "New []");
	void   operator delete [] (void* ptr);
};

void * SomeClass::operator new( size_t size,char* str)
{	
	cout &lt;&lt;"\n"&lt;&lt;str&lt;&lt;"\n";	
	/*
	Здесь, для выделения памяти используется стандартная функция 
	void *malloc( size_t size );
	В неё передаётся size - количество байт, которое нужно 
	выделить. Если память выделяется, то из malloc возвращается 
	адрес начала выделенного блока.
	*/
	void*ptr = malloc(size);

	if(!ptr){
		cout&lt;&lt;"\nError memory new!!!\n";
	}
	else{
		cout&lt;&lt;"\nMemory new - OK!!!\n";
	}
	return ptr;	
}
void * SomeClass::operator new[]( size_t fullsize,char* str)
{
	cout &lt;&lt;"\n"&lt;&lt;str&lt;&lt;"\n";	
	/*
	Здесь, для выделения памяти используется стандартная функция 
	void *malloc( size_t size );
	В неё передаётся size - количество байт, которое нужно 
	выделить. Если память выделяется, то из malloc возвращается 
	адрес начала выделенного блока.
	*/
	void*ptr = malloc(fullsize);

	if(!ptr){
		cout&lt;&lt;"\nError memory new[]!!!\n";
	}
	else{
		cout&lt;&lt;"\nMemory new[] - OK!!!\n";
	}
	return ptr;	
}

void SomeClass::operator delete( void* ptr)
{
	
	/*
	Для очистки памяти используется стандартная функция
	void free( void * memblock );
	Функция free очищает память, memblock - адрес начала
	очищаемого участка
	*/
	free(ptr);
	cout&lt;&lt;"\nDelete memory\n";
}

void SomeClass::operator delete[](void* ptr)
{
	free(ptr);
	cout&lt;&lt;"\nDelete [] memory\n";
}

void main()
{
	/*
	Вызывается 
	оператор new( size_t size,char* str="New")
	на место size будет подставлен размер класса SomeClass,
	а str получит значение по умолчанию т.е. "New"
	*/
	SomeClass *p = new SomeClass;

	/*
	Вызывается 
	оператор new[](size_t size,char* str="New[]")
	на место size будет подставлен размер класса SomeClass,
	умноженный на количество запрашиваемых элементов
	а str получит значение по умолчанию т.е. "New[]"
	*/
	SomeClass *r = new SomeClass [3];	

	/*
	Вызывается оператор delete(void* ptr)
	на место ptr будет подставлен размер адрес памяти,
	выделенной под объект р
	*/
	delete p;

	/*
	Вызывается оператор delete[](void* ptr)
	на место ptr будет подставлен размер адрес памяти,
	выделенной под объект r
	*/
	delete[]r;	
}

_____________________________________________________

Результат работы программы:

New

Memory new - OK!!!

New []

Memory new[] - OK!!!

Delete memory

Delete [] memory
</example>
</lesson>