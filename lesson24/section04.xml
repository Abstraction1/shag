<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №24" next="section05.xml" prev="section03.xml" summ="0">
<h2>Дружественные классы.</h2>

<p>
Пора узнать, что "дружить" могут не только функции. Класс тоже может быть дружественным другому классу. 
</p>

<h5>Особенности "дружбы" между классами.</h5>
<p>1. Дружественный класс должен быть определен вне тела класса, "предоставляющего дружбу".</p>
<p>2. Все компонентные функции класса-друга будут являтся дружественными для другого класса без указания спецификатора friend.</p> 
<p>3. Все компоненты класса доступны в дружественном классе, но не наоборот.</p>
<p>4. Дружественный класс может быть определен позже (ниже), чем описан как дружественный.</p> 

<p>
Рассмотрим простой пример, иллюстрирующий вышесказанное.
</p>    

<example>
# include &lt;iostream&gt;
using namespace std;
// упоминание о классе,
// который будет описан ниже
class	Banana;

// класс, который будет
// дружественным
class	Apple{
public:	
	void F_apple(Banana ob);
};
// класс, который "позволяет" с собой "дружить"
class	Banana{	
	int	x,y;
public:	
	Banana(){
		x=y=777;
	}	
	// реализация дружбы
	friend	Apple;
};
//функция, которая
//автоматически становится "другом"
void Apple::F_apple(Banana ob)
{	
	//обращение к private - членам
	cout&lt;&lt;ob.x&lt;&lt;"\n";
	cout&lt;&lt;ob.y&lt;&lt;"\n";
}
void main(){
	Banana b;
	Apple a;
	a.F_apple(b);
}
</example>

</lesson>