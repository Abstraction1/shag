<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №24" next="hometask.xml" prev="section04.xml" summ="0">
<h2>Статические члены класса. </h2>
<p>
Каждый объект одного и того же класса имеет собственную копию данных класса. Можно сказать, что данные класса тиражируются при каждом определении объекта этого класса. Отличаются они друг от друга именно по "привязке" к тому или иному объекту. Это не всегда соответствует требованиям решаемой задачи. Например, при формировании объектов класса может потребоваться счетчик объектов. Безусловно, такой счетчик можно сделать компонентом класса, но иметь его нужно только в единственном числе. Чтобы компонент класса был в единственном экземпляре и не тиражировался при создании каждого нового объекта класса, он должен быть определен в классе как статический и иметь атрибут static. 
</p>

<h3>Статические поля класса. </h3>

<p>
Итак, поле класса можно объявить со служебным словом static. Память под такие поля резервируется при запуске программы, то есть еще до того, как программист явно создаст первый объект данного абстрактного типа.При этом все объекты, сколько бы их ни было, используют эту заранее созданную одну - единственную копию своего статического члена. 
</p>

<p>
Статический член класса должен быть инициализирован после определения класса и до первого описания объекта этого класса. Данное действие производится с помощью так называемого полного или квалифицированного имени статического члена, которое имеет вид:
</p>

<example>

имя_класса::имя_статического_члена 
</example>

<p>
Рассмотрим пример. Реализуем класс object_, в статическом члене которого хранится число существующих в каждый момент времени объектов типа object_. 
</p>

<example>
# include &lt;iostream&gt;
# include &lt;string.h&gt;
using namespace std;

class object_{ 
    char *str;
public:
	//статическое поле класса
	static int num_obj;
	
	//конструктор
    	object_ (char *s){
        	str = new char [strlen (s) + 1]; 
		strcpy ( str, s ); 
		cout &lt;&lt;"Create " &lt;&lt; str &lt;&lt;'\n';

		// увеличиваем значение счетчика 
		num_obj ++ ; 
    	} 

	//деструктор
    	~object_ (){ 
		cout &lt;&lt;"Destroy " &lt;&lt; str &lt;&lt; '\n'; 
		delete str;
 
		// уменьшаем значение счетчика 
		num_obj --; 
    	} 
}; 

// Инициализация. Об этом говорит
// ключевое слово int! 
int object_::num_obj = 0; 

// создание глобальных объектов
object_ s1 ("First global object."); 
object_ s2 ("Second global object."); 

// вспомогательная функция
void f (char *str) { 
	 // Локальный объект
     	object_ s(str); 
	 // явное обращение к статическому полю
	 // без указания объекта
     	cout &lt;&lt;"Count of objects - " &lt;&lt;object_::num_obj&lt;&lt;".\n"; 
     	cout &lt;&lt;"Worked function f()" &lt;&lt;".\n";
} 

void main () { 
	// явное обращение к статическому полю
     	cout &lt;&lt;"Now, count of objects " &lt;&lt;object_::num_obj&lt;&lt;".\n";
	object_ M ("Object in main ()."); 

	// обращение к статическому полю через объект
     	cout &lt;&lt;"Now, count of objects" &lt;&lt; M.num_obj &lt;&lt;".\n";

	f ("Local object."); 
        f ("Another local object."); 

     	cout &lt;&lt; "Before finish main() count of objects - " &lt;&lt;object_::num_obj&lt;&lt;".\n";
} 

Результаты работы программы:

Create First global object.
Create Second global object.
Now, count of objects 2.
Create Object in main ().
Now, count of objects3.
Create Local object.
Count of objects - 4.
Worked function f().
Destroy Local object.
Create Another local object.
Count of objects - 4.
Worked function f().
Destroy Another local object.
Before finish main() count of objects - 3.
Destroy Object in main ().
Destroy Second global object.
Destroy First global object.

</example>

<tip start="Примечание"> 
Обратим внимание, что конструкторы для глобальных объектов вызываются до функции main (), а деструкторы после main().
</tip> 

<p>
На статические данные класса распространяются правила статуса доступа. Если статические данные имеют статус private, то к ним извне можно обращаться через компонентные функции. Другими словами, получается, что, если к моменту необходимости обращения к статическому полю типа private, объект класса еще не определен, обрашение невозможно. Согласитесь, хотелось бы иметь возможность обойтись без имени конкретного объекта при обращении к статическим данным класса. Эта задача решается с помощью статической компонентной функции-метода. 
</p>

<h3>Статические методы класса.</h3>

<p>
Перед объявлением функции-члена класса можно поставить служебное слово static и она становится - статической компонентной функцией. Такая функция сохраняет все основные особенности обычных (нестатических) функций класса. К ней можно обращаться, используя имя уже существующего объекта класса либо указатель на такой объект. 
</p>
<p>
Кроме того, статическую компонентную функцию можно вызвать следующим образом:
</p>

<example>
имя_класса::имя_статической_функции
</example>

<p>
Статические функции-члены позволяют получить доступ к приватным статическим данным-членам класса, не имея еще ни одного объекта данного типа в программе. 
</p>

<p>Но, внимание!!!</p>

<p><b> 
Для статической компонентной функции не определен указатель this. Когда это необходимо, адрес объекта, для которого вызывается статическая функция-член, должен быть передан ей явно в виде аргумента.
</b></p>

<p>
Рассмотрим пример:
</p>

<example>

# include &lt;iostream&gt;
using namespace std;

class prim{ 

     	int numb;
	// статическое поле
	static stat_; 

public: 
     	prim (int i) { 
		numb=i; 
     	}
 
     	/*
	Статическая функция. Указатель this не определен, 
	поэтому выбор объекта осуществляется по явно
	переданному указателю. Поле stat_ не требует
	указателя на объект,т.к. оно общий для всех объектов класса prim. 
     	*/ 
     	static void func (int i, prim *p = 0) {
		// если хотя бы один объект есть 
		if(p)
			p->numb = i; 
		// если объектов класса нет
        	else 
			stat_ = i; 
     	} 

	/*
	Статическая функция обращается только к
        статическому члену класса, никаких указателей не требуется. 
	*/
     	static void show(){ 
		 cout&lt;&lt;"stat_="&lt;&lt;stat_&lt;&lt;"\n\n";
	} 

	//показ нестатического члена
	void show2(){
		 cout&lt;&lt;"numb="&lt;&lt;numb&lt;&lt;"\n\n";
	}
};  

// Инициализация статического члена класса. 
int prim::stat_ = 8; 

void main(){ 

     	/*
	До создания объектов типа prim возможен
	единственный способ обращения к статической 
	функции-члену.
	*/ 
     	prim::show (); 

     	// Можно изменить значение статического члена класса. 
     	prim::func(10); 

     	/*
	После создания объекта типа prim можно обратиться
	к статической функции обычным для абстрактных типов способом. 
	*/
	 
	// Создается объект obj и его поле numb 
	// становится равным 23.  
     	prim obj(23);
     	obj.show2(); 

     	// Можно изменить значение созданного объекта. 
     	prim::func(20, &amp;obj); // obj.numb 20. 
	obj.show2(); 

     	obj.func(27, &amp;obj); // obj.numb 27. 
	obj.show2(); 
} 
</example>

<h3>Шаблон Синглетон (Singleton pattern)</h3>

<p>
Одним из применений статических членов является конструкция под названием Singleton pattern. Данная конструкция позволяет создавать только один экземпляр класса, и обеспечивает глобальный доступ к этому экземпляру.
</p>

<p>
Иногда бывает очень важно, чтобы класс мог создать только один экземпляр (объект). Например, система может иметь несколько принтеров, но должен быть только один спулер принтера. Как мы можем гарантировать, что имеется только один экземпляр класса, и что этот экземпляр доступен?! Можно, например, объявить глобальную переменную. Однако, данный способ плох тем, что мы во-первых засоряем пространство имен, а во-вторых не можем предотвратить создание нескольких экземпляров класса.
</p>
<p>
Лучшим решением будет класс, который сам отслеживает создание экземпляров и доступ к единственному объекту. Мы можем сделать так, чтобы класс гарантировал, что никакой другой экземпляр не может быть создан. 
</p>
<p>
Надо написать класс, у которого можно создать только один экземпляр, но этим экземпляром должны пользоваться объекты других классов. Вот, пожалуй, самая простая из схем, реализующих эту задачу.
</p>

<example>
# include &lt;iostream&gt;
using namespace std;

class Singleton{ 

private: 
	
	// указатель на единственный экземпляр класса
	static Singleton*s;  
	int k; 

	//закрытый конструктор
	Singleton(int i){
		k = i;
	}  

public:
	//функция для получения указателя на 
	//единственный экземпляр класса
	static Singleton*getReference(){
	   return s;
	}  

	//получение значения нестатического члена класса
	int getValue(){
		return k;
	}  

	//перезапись значения нестатического члена класса
	void setValue(int i){
		k = i;
	} 
};  

// Инициализация статического члена класса.
Singleton* Singleton::s=new Singleton(3); 

void main(){  

	//получение указателя на 
	//единственный экземпляр класса
	Singleton*p=Singleton::getReference();

	//работа с компонентом объекта
	cout&lt;&lt;p->getValue()&lt;&lt;"\n\n";
	p->setValue(p->getValue()+5);
	cout&lt;&lt;p->getValue()&lt;&lt;"\n\n";
} 
</example>

<h5>Комментарии к примеру.</h5>

<p>Класс Singleton окончательный — его нельзя расширить.</p>
<p>Его конструктор закрытый — никакой метод не может создать экземпляр этого класса.</p>
<p>Единственный экземпляр s класса Singleton — статический, он создается внутри класса.</p>
<p>Однако можно получить указатель на этот экземпляр методом getReference(), изменить состояние экземпляра s методом setValue() или просмотреть его текущее состояние методом getValue().
</p>
<hr/> 
<p>Безусловно, это только схема — класс Singleton надо еще наполнить полезным содержимым, но идея выражена ясно и полностью.
</p>

</lesson>