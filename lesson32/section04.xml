<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №32" next="section05.xml" prev="section02.xml" summ="0">
<h2>Абстрактные классы. </h2>
<p>
Давайте продолжим рассмотрение использования виртуальных функций. На этот раз мы с вами разберем простой пример. Но, для начала, еще немного теории.
</p>

<h4>Чисто виртуальные функции</h4>

<p>
Слово "чисто" – в данном случае используется в контексте "пусто". Иными словами, чисто виртуальная функция - функция пустая. Синтаксис создания её таков:
</p>

class A
{
	public:
	//чисто виртуальная функция 
	virtual void v_function()=0;
};

<p>
Как видите, все отличие только в том, что появилась конструкция «=0», которая называется «чистый спецификатор». Чисто виртуальная функция абсолютно ничего не делает и недоступна для вызовов. Ее назначение – служить основой (если хотите, шаблоном) для замещающих функций в производных классах.
</p>
<p>
Класс, который содержит хотя бы одну чисто виртуальную функцию, называется абстрактным классом. Это связано с тем, что создавать самостоятельные объекты такого класса нельзя. Это всего лишь заготовка для других классов. Механизм абстрактных классов разработан для представления общих понятий, которые в дальнейшем предполагается конкретизировать. Эти общие понятия обычно невозможно использовать непосредственно, но на их основе можно, как на базе, построить производные частные классы, пригодные для описания конкретных объектов.
</p>

<tip start="Примечание">
Приведем пример. Все животные в своем поведении имеют такие функции, как «есть», «пить», «спать», «издавать звук». Имеет смысл определить базовый класс, в котором сразу объявить все эти функции и сделать их чисто виртуальными. А потом из этого класса выводить классы, описывающие конкретных животных (или виды), со своим специфичным поведением. А базовый класс при этом действительно получается абстрактным. Ведь он не описывает никакое более-менее конкретное животное (даже вид животных). Это может быть и рыба и птица....
</tip>
<p>
По сравнению с обычными классами, абстрактные классы пользуются «ограниченными правами».
</p>

<ul>
<li>Как и всякий класс, абстрактный класс может иметь явно определенный конструктор. Из конструктора можно вызывать методы класса. Но обращение из конструктора к чистым виртуальным функциям приведут к ошибкам во время выполнения программы.</li>

<li>Как уже говорилось, невозможно создать объект абстрактного класса. </li>

<li>Абстрактный класс нельзя применять для задания типа параметра функции, или в качестве типа возвращаемого значения.</li>

<li>Его нельзя использовать при явном приведении типов. Зато можно определять ссылки и указатели на абстрактные классы.</li>
</ul>

<h4> Пример.</h4>

<p>
Рассмотрим пример иерархии классов, описывающих неких животных. Для упрощения примера ограничимся в описании каждого животного его кличкой и издаваемым животным звуком. Ну, а основной возможностью программы будет вывод на экран списка кличек животных и представления издаваемых ими звуков.
</p>

<example>

#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

//абстрактный базовый класс
class Animal
{
	public:	
		//кличка животного
		char Title[20]; 
		//простой конструктор
		Animal(char *t){
			strcpy(Title,t);
		} 
		//чисто виртуальная функция
		virtual void speak()=0; 
};

//класс лягушка
class Frog: public Animal
{
	public:
		Frog(char *Title): Animal(Title){};
		virtual void speak(){ 
			cout&lt;&lt;Title&lt;&lt;" say "&lt;&lt;"\'kwa-kwa\'\n"; 
		}
};

//класс собака
class Dog: public Animal
{
	public:
		Dog(char *Title): Animal(Title){};
		virtual void speak(){
			cout&lt;&lt;Title&lt;&lt;" say "&lt;&lt;"\'gav-gav\'\n";
		}
};

//класс кошка
class Cat: public Animal
{
	public:
		Cat(char *Title): Animal(Title){};
		virtual void speak(){
			cout&lt;&lt;Title&lt;&lt;" say "&lt;&lt;"\'myau-myau\'\n";
		}
};

//класс лев
class Lion: public Cat
{
	public:
		Lion(char *Title): Cat(Title) {};
		/*virtual void speak(){ 
			cout&lt;&lt;Title&lt;&lt;" say "&lt;&lt;"\'rrr-rrr\'\n";
		}*/

		/*virtual int speak(){
			cout&lt;&lt;Title&lt;&lt;" say "&lt;&lt;"\'rrr-rrr\'\n";
			return 0;
		}*/

		virtual void speak(int When){
			cout&lt;&lt;Title&lt;&lt;" say "&lt;&lt;"\'rrr-rrr\'\n";
		}
};


void main ()
{
	// объявим массив указателей на базовый класс Animal
	// и сразу его заполним указателями, создавая объекты
	// cписок животных
	Animal *animals[4] = {new Dog("Bob"),
						  new Cat("Murka"),
						  new Frog("Vasya"),
						  new Lion("King")}; 

	for(int k=0; k&lt;4; k++)
		animals[k]->speak();
}

</example>

<p>
В качестве базового класса создан абстрактный класс Animal. Он имеет единственный член Title, описывающий кличку животного. В нем есть явно определенный конструктор, который присваивает животному его «имя». И, единственная чисто виртуальная функция speak(), которая описывает, какие звуки издает животное.
</p>

<p>
От этого класса отнаследованны все остальные. Кроме одного. Класс «лев» порожден от класса «кошка» (львы это тоже кошки). Это сделано для демонстрации тонкостей применения виртуальных функций. Но об этом классе немного позже. 
</p>
<p>
Во всех производных классах также описана собственная замещающая виртуальная функция speak(), которая печатает на экран, звуки, которые издает конкретное животное.
</p>

<p>
В основном теле программы объявлен массив animals[4] указателей типа Animal*. И сразу же созданы динамические объекты классов и заполнен массив указателей. А в цикле for() по указателю просто вызывается виртуальная функция speak().
</p>

<p>
Результат работы программы таков:
</p>

<example>
Bob say 'gav-gav'
Murka say 'myau-myau'
Vasya say 'kwa-kwa'
King say 'rrr-rrr'
</example>
<p>
Теперь обратимся к описанию класса Lion (лев). В нем вместо одной виртуальной функции speak() содержится сразу три. Две из них закомментированы.
</p>


<p>
Если вы закомментируете первую функцию, а раскомментируете вторую, то сможете проверить вариант, когда производится попытка соорудить виртуальную замещающую функцию с другим типом возвращаемого значения. В данном случае вторая (неправильная) функция возвращает тип int вместо типа void, который был у функции speak()в базовом классе. Попробуйте скомпилировать программу и произойдет ошибка на этапе компиляции.
</p>

<p>
Теперь, попробуйте раскомментировать третью функцию, а первые две закомментируйте. Компилятор на сей раз просто выдаст только предупреждение. Это тот самый случай, когда объявляется замещающая виртуальная функция с тем же самым типом возвращаемого значения, но с другим набором параметров. Посмотрим, что получилось:
</p>
<example>
Bob say 'gav-gav'
Murka say 'myau-myau'
Vasya say 'kwa-kwa'
King say 'myau-myau'
</example>
<p>
Лев у нас уже не рычит, а мяукает. Это потому, что работает уже совсем другая функция! То есть, раз в данном классе нет правильно определенной виртуальной функции, то по указателю вызывается виртуальная функция speak() из базового класса. А в нашем случае базовым для класса Lion является класс Cat. Вот лев и замяукал.
</p>
</lesson>