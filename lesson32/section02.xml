<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №32" next="section04.xml" prev="section01.xml" summ="1">
<h2>Раннее и позднее связывание. Статический и динамический полиморфизм. </h2>

<p>
Мы только что познакомились с виртуальными функциями и, теперь, нам необходимо рассмотреть такие понятия как раннее и позднее связывание. Приступим.
</p>

<p>
Сравним два подхода к покупке, к примеру, килограмма апельсинов. В первом случае мы заранее знаем, что нам надо купить 1 кг. апельсинов. Поэтому мы берем небольшой пакет, не много, но достаточно денег, чтобы хватило на этот килограмм. Во втором случае, мы, выходя из дома, не знаем что и как много нам надо купить. Поэтому мы берем машину (а вдруг будет много всего), запасаемся пакетами больших и малых размеров и берем как можно больше денег. Едем на рынок и выясняется, что надо купить только 1 кг. апельсинов.
</p>

<p>
Приведенный пример в определенной мере отражает смысл применения раннего и позднего связывания, соответственно. Очевидно, что для данного примера первый вариант оптимален. Во втором случае мы слишком много всего предусмотрели, но нам это не понадобилось. С другой стороны, если по дороге на рынок мы решим, что апельсины нам не нужны и решим купить 10 кг. яблок, то в первом случае мы уже не сможем этого сделать. Во втором же случае - легко.
</p>

<p>
А, теперь, рассмотрим этот пример с точки зрения программирования. При применении раннего связывания, мы как бы говорим компилятору: "Я точно знаю, чего я хочу. Поэтому статически связывай все вызовы функций". При применении механизма позднего связывания мы как бы говорим компилятору: "Я пока не знаю чего я хочу. Когда придет время, я сообщу что и как я хочу".
</p>

<p>
Таким образом, во время раннего связывания вызывающий и вызываемый методы связываются при первом удобном случае, обычно при компиляции.
</p>

<p>
При позднем связывании вызываемого метода и вызывающего метода они не могут быть связаны во время компиляции. Поэтому реализован специальный механизм, который определяет как будет происходить связывание вызываемого и вызывающего методов, когда вызов будет сделан фактически. Именно этот механизм и реализуют виртуальные функции.
</p>

<p>
Очевидно, что скорость и эффективность при раннем связывании выше, чем при использовании позднего связывания. В то же время, позднее связывание обеспечивает некоторую универсальность связывания.
</p>

<p>
И, напоследок, давайте чётко сформулируем определение того свойства ООП, реализацией которого является связывание:
</p>
<p>
<b>
Полиморфизм - переопределение наследником функций-членов базового класса. Полиморфизм бывает динамическим, когда вызываемая функция определяется во время выполнения (позднее связывание) и статическим (раннее связывание).
</b>
</p>


</lesson>
