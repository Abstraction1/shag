<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №22" next="section02.xml" prev="index.xml" summ="1">
<h2>Константный метод.</h2>

<p>
Говорят, что метод объекта обладает свойством неизменности (константности), если после его выполнения состояние объекта не изменяется.Если не контролировать свойство неизменности, то его обеспечение будет целиком зависеть от квалификации программиста. Если же "неизменный" метод в процессе выполнения будет производить посторонние эффекты, то результат может быть самым неожиданным,отлаживать и поддерживать такой код очень тяжело.
</p>

<p>
Язык С++ позволяет пометить метод как константный. При этом неконстантные методы объекта запрещается использовать в теле помеченного метода, и в контексте этого метода ссылки на сам объект и все его поля будут константны. Для обозначения константности, используется модификатор const.
</p>

<tip start="Примечание">Кстати!!!
Также существует возможность пометить ссылку (или указатель) как константную. Применительно к ссылке свойство константности означает, что через эту ссылку можно вызывать только константные методы. Присвоение константной ссылки неконстантной запрещено.
</tip>

<p>
Давайте, рассмотрим пример класса с константными методами:
</p>

<example>
# include &lt;iostream&gt;
# include &lt;string.h&gt;
using namespace std;
class Personal
{
public:
	// конструктор с параметрами
	// мы выделяем здесь память
	// однако в нашем примере нет
	// ни деструктора, ни конструктора
	// копирования - единственная цель,
	// которую мы преследуем показать 
	// работу константного метода
	Personal(char*p,char*n,int a){
        name=new char[strlen(n)+1];
		if(!name){
			cout&lt;&lt;"Error!!!";
			exit(0);
		} 
		picture_data=new char[strlen(n)+1];
		if(!picture_data){
			cout&lt;&lt;"Error!!!";
			exit(0);
		}
		strcpy(picture_data,p);
		strcpy(name,n);
		age=a;
	}

	// Группа константных методов
	// внутри них невозможно
	// изменить какое-то из свойств
	const char*Name()const{
		return name;
	}
	int Age()const{
		return age;
	}
	const char*Picture()const{
		return picture_data;
	}

	void SetName(const char*n){
		strcpy(name,n);
	}
	void SetAge(int a){
		age=a;
	}
	void SetPicture(const char*p){
		strcpy(picture_data,p);
	}

private:
	char*picture_data; // путь к фотографии
	char*name; // имя
	int age; // возраст
};

void main(){
	Personal A("C:\\Image\\","Ivan",23);
	cout&lt;&lt;"Name: "&lt;&lt;A.Name()&lt;&lt;"\n\n";
	cout&lt;&lt;"Age: "&lt;&lt;A.Age()&lt;&lt;"\n\n";
	cout&lt;&lt;"Path for picture: "&lt;&lt;A.Picture()&lt;&lt;"\n\n";
	A.SetPicture("C:\\Test\\");
	A.SetName("Leonid");
	A.SetAge(90);
	cout&lt;&lt;"Name: "&lt;&lt;A.Name()&lt;&lt;"\n\n";
	cout&lt;&lt;"Age: "&lt;&lt;A.Age()&lt;&lt;"\n\n";
	cout&lt;&lt;"Path for picture: "&lt;&lt;A.Picture()&lt;&lt;"\n\n";
}
</example>

<p>
В данном примере методы Name, Age, Picture объявлены константными. Кроме того, можно наблюдать и использование константных указателей: параметр методов SetName и SetPicture, возвращаемое значение методов Name и Picture. Компилятор обеспечит проверку того, что реализация константных методов не имеет побочных эффектов в виде изменения состояния объекта, реализующего класс Personal. Как только обнаружится попытка выполнить запрещенную операцию, компилятор сообщит об ошибке. 
</p>
</lesson>
