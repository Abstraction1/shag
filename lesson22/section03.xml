<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №22" next="section04.xml" prev="section02.xml" summ="0">
<h2>Перегрузка операторов.</h2>

<p>
В С++ есть возможность распространения действия стандартных операций на операнды абстрактных типов данных. Для того, чтобы переопределить одну из стандартных операций для работы с операндами абстрактных типов, программист должен написать функцию с именем <b>operator знак</b>, где знак - обозначение этой операции (например, +  -  |  += и т.д.).
</p> 

<p>
Однако в языке существует несколько ограничений, накладываемых на переопределение операторов:
</p> 
<ol>
<li>Нельзя создавать новые символы операций.</li> 
<li>Нельзя переопределять операции:</li>
<example>
::
* (разыменование, а не бинарное умножение)
?: 
sizeof
## 
#
.
</example>
<li>
Cимвол унарной операции не может использоваться для переопределения бинарной операции и наоборот. Например, символ &lt;&lt; можно использовать только для бинарной операции, ! - только для унарной, а &amp; - и для унарной, и для бинарной.
</li>
<li> 
Переопределение операций не меняет ни их приоритетов, ни порядка их выполнения (слева направо или справа налево).
</li> 
<li>
При перегрузке операции компьютер не делает никаких предположений о ее свойствах. Это означает, что если стандартная операция += может быть выражена через операции + и =, т.е. а + = b эквивалентно а = а + b, то для переопределения операций в общем таких соотношений не существует, хотя, конечно, программист может их обеспечить. 
</li>
<li>
Никакая операция не может быть переопределена для операндов стандартных типов.
</li> 
<li>
Как для унарной, так и для бинарной операции число аргументов функции operator () должно точно соответствовать числу операндов этой операции. Причем в перегрузку бинарного оператора принято передавать один аргумент, так как второй - неявный. Его имеет любая функция - член класса, это тот самый указатель this - указатель на объект, для которого вызван метод. Таким образом, в переопределение унарного оператора не следует передавать ничего вовсе.
</li>
</ol>
<tip start="Примечание">Кстати!! Удобно передавать значения параметров в функцию operator() не по значению, а по ссылке.</tip>
<h5>Пример.</h5>
<example>
#include &lt;iostream&gt;

using namespace std;
class Digit{
	private:
		int dig; // число
	public:
		Digit(){
			dig=0;
		}
		Digit(int iDig){
			dig=iDig;
		}
		void Show(){
			cout&lt;&lt;dig&lt;&lt;"\n";
		}

		// перегружаем четыре оператора
		// обратите внимания, все операторы
		// бинарные, поэтому мы передаем в
		// них один параметр - это операнд,
		// который будет находиться справа
		// от оператора в выражении
		// левый операнд передается с помощью this
		Digit operator+(const Digit &amp;N)
		{
			Digit temp;
			temp.dig=dig+N.dig;
			return temp;
		}
		Digit operator-(const Digit &amp;N)
		{
			Digit temp;
			temp.dig=dig-N.dig;
			return temp;
		}
		Digit operator*(const Digit &amp;N)
		{
			Digit temp;
			temp.dig=dig*N.dig;
			return temp;
		}
		Digit Digit::operator%(const Digit &amp;N)
		{
			Digit temp;
			temp.dig=dig%N.dig;
			return temp;
		}		
};
void main()
{
	// проверяем работу операторов
	Digit A(8),B(3);
	Digit C;

	cout&lt;&lt;"\Digit A:\n";
	A.Show();

	cout&lt;&lt;"\Digit B:\n";
	B.Show();

	cout&lt;&lt;"\noperator+:\n";
	C=A+B;
	C.Show();

	cout&lt;&lt;"\noperator-:\n";
	C=A-B;
	C.Show();

	cout&lt;&lt;"\noperator*:\n";
	C=A*B;
	C.Show();
	
	cout&lt;&lt;"\noperator%:\n";
	C=A%B;
	C.Show();
}
</example>
</lesson>