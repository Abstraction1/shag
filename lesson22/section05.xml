<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №22" next="hometask.xml" prev="section04.xml" summ="0">
<h2>Пример класса СТРОКА с перегруженными операторами.</h2>

<p>Теперь, на основании полученных знаний дополним класс СТРОКА, описанный в уроке. А, именно - добавим в него функцию сцепления строк, используя перегрузку бинарного оператора +, перегрузим операцию присваивания и создадим возможность преобразования строки к нашему объекту.</p>
<example>
#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

class string_                
{
private:
	// Строка
	char* S;

	// Длина строки
	int len;  
public:
	// Конструктор по умолчанию
	// без параметров
	string_();

	// Перегруженный конструктор
	// с параметром
	string_(char* s); 
	
	// Конструктор копирования
	string_(const string_&amp; s); 
	
	// Деструктор
	~string_(){ 
		delete [] S;
	}  

	// Метод сортировки
	void Sort(string_ s[], int n);   

	// Константный метод
	// возвращающий содержимое
	// строки
	const char*GetStr()const 
	{ 
		return S;		
	}
	// метод позволяющий изменить содержимое
	// с помощью пользователя
	void SetStr() 
	{
		// если строка не пустая - очистить
		if(S!=NULL)
			delete[]S;
		
		// создаем массив
		// и запрашиваем у пользователя данные
		char a[256]; 
		cin.getline(a,256); 

		// просчитываем размер
		len=strlen(a)+1;

		// выделяем память
		S = new char[len];

		// переписываем в объект
		// введенную строку
		strcpy(S,a); 
	}

    // Перегрузка бинарного оператора
	// Первый параметр передается неявно с помощью указателя this
	// Функция реализует сцепление строк
    string_ operator+(const string_&amp;);    

	// Перегрузка бинарного оператора
	// Первый параметр передается неявно с помощью указателя this
    // Функция реализует корректное присваивание объектов друг другу
	// в ситуации объект1=объект2. Напоминаем, эта ситуация является
	// четвертым случаем побитового копирования, при котором
	// конструктор копирования - бессилен.
    string_&amp;operator=(const string_&amp;);

    // Перегрузка типа
    // Функция реализует преобразование объекта класса к типу char*
    operator char*() { return S; }
};

string_::string_()
{
	// Начальная инициализация
	S = NULL;       
	len = 0;
}

string_::string_(char* s)
{
	len = strlen(s);
	S = new char[len + 1];
	// Инициализация строкой,
	// переданной пользователем
	strcpy(S, s);           
}

string_::string_(const string_&amp; s)
{
	len = s.len;
	// Безопасное копирование
	S = new char[len + 1];  
	strcpy(S, s.S);
}

void string_::Sort(string_ s[], int n)
{ 
	//  Сортировка строк
	//  Методом пузырька
	
	string_ temp;	

	for(int i=0;i&lt;n-1;i++)	
	{
		for(int j=n-1;j&gt;i;j--)
		{
			// сравнение двух строк
			if(strcmp(s[j].S,s[j-1].S)&lt;0)
			{
				// теперь, когда у нас есть
				// перегруженный оператор равно
				// мы не нуждаемся в дополнительной
				// функции SetStr2, которую использовали
				// в прошлом примере для присваивания

				// запись стороки s[j] в temp
				temp=s[j];

				// запись стороки s[j-1] в s[j]
				s[j]=s[j-1];

				// запись стороки temp в s[j-1]
				s[j-1]=temp;               
			}
		}
	}
}

// Функция сцепления строк (перегруженный
// бинарный плюс)
string_ string_::operator+(const string_ &amp;str)
{  
	// Создание временного объекта                            
    string_ s;
	
	// Вычисление новой длины строки
    s.len = len + str.len;      

	// Выделение памяти под новую строку
    s.S = new char[s.len + 1];

	// Инициализация первой части строки
    strcpy(s.S, S);

	//  Инициализация второй части строки             
    strcat(s.S, str.S);
	
	//  Возврат нового объекта         
    return s;                   
}

// Функция, реализующая безопасное присваивание
string_&amp; string_::operator=(const string_ &amp;str)
{                               
    // Предотвращение варианта STRING = STRING; 
    // (присваивание самому себе),
    // где STRING переменная класса string    	                        
    if(this == &amp;str) 
         return *this;
    
	// если размеры строк не совпадают
	// или строка, в которою производится запись
	// не сформированна
    if(len != str.len || len == 0)
    {
		// Удаление старой строки
        delete [] S;
		// Вычисление новой длины строки            
        len = str.len;
		// Выделение памяти под новую строку          
        S = new char[len + 1];  
    }

	// Инициализация строки
    strcpy(S, str.S);

	// Возврат ссылки на "самого себя"
    // Благодаря этому возможно многократное
    // присваивание объектов друг другу
    // например, string_ a, b, c; a = b = c;           
    return *this;               
}


void main()
{
	int n,i;

	// Вводим количество строк
	cout &lt;&lt; "Input the number of string s:\t";
	cin &gt;&gt; n;           

	if(n &lt; 0)
	{
		cout &lt;&lt; "Error number:\t" &lt;&lt; n &lt;&lt; endl;
		return;
	}

	// Забираем из потока символ Enter ("\n")
	char c[2];          
	cin.getline(c, 2);

	// Создаем массив из n строк
	string_ *s = new string_[n];  

	// Ввод строк c клавиатуры
	for(i = 0; i &lt; n; i++)
		s[i].SetStr();          

	// Сортировка строк
	// Вызов через указатель,
	// так как функция работает
	// для группы объектов,
	// а не для одного конкретного
	s->Sort(s, n);		

	// Вывод отсортированных строк
	for(i = 0; i &lt; n; i++)
		cout&lt;&lt;"\n"&lt;&lt;s[i].GetStr()&lt;&lt;"\n"; 			

	// Удаление массива строк
	delete [] s;	

	cout&lt;&lt;"\n\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n";

	//Проверяем на деле оператор + и преобразование

	string_ A,B,C,RES;

	A="Ivanov ";
	B="Ivan ";
	C="Ivanovich";
	RES=A+B+C;
	cout&lt;&lt;RES.GetStr()&lt;&lt;"\n\n";
}

</example>


</lesson>