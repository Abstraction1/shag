<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №18" next="hometask.xml" prev="section4.xml" summ="1">
<h2>Разнесение проекта по несколько файлов.</h2>
<p>Как Вы уже давно знаете, для включения текста из файла используется команда #include. Пора познакомиться с ней поближе. Эта команда является директивой препроцессора и имеет две формы записи: </p>
<example>
#include &lt;имя_файла&gt;// Имя в угловых скобках.
     #include "имя_файла"// Имя в кавычках.
</example>
<p>Если <b>имя_файла</b> - в угловых скобках, то препроцессор разыскивает файл в стандартных системных каталогах. Если <b>имя_файла</b> заключено в кавычки, то вначале препроцессор просматривает текущий каталог пользователя и только затем обращается к просмотру стандартных системных каталогов. </p>
<p>Начиная работать с языком C, мы сразу же столкнулись с необходимостью использования в программах средств ввода-вывода. Для этого в начале текста программы мы размещали директиву: </p>
<example>#include &lt;iostream&gt;</example>
<p>Выполняя эту директиву, препроцессор включает в программу средства связи с библиотекой ввода-вывода. Поиск файла <b>iostream</b> ведется в стандартных системных каталогах. </p>
<p>Заголовочные файлы оказываются весьма эффективным средством при модульной разработке крупных программ. Также, в практике программирования на С обычна ситуация, при которой, если в программе используется несколько функций, то удобно тексты этих функций хранить в отдельном файле. При подготовке программы пользователь включает в нее тексты используемых функций с помощью команд <b>#include</b>. </p>
<p>В качестве примера рассмотрим задачу обработки строк, в которой используем функции обработки строк, тексты которых находятся в отдельном файле.</p>
<h5>Пример программы.</h5>
<p>Ввести с клавиатуры заканчивающееся точкой предложение, слова в котором отделены друг от друга пробелами. Записать каждое слово предложения в обратном порядке (инвертировать слово) и напечатать полученное предложение. Для простоты реализации ограничим длину вводимого предложения 80 символами. Тогда программа решения сформулированной задачи может быть такой: </p>
<p>Основной файл:</p>
<example>
#include &lt;iostream&gt;
using namespace std;
// Файлйл написанный самостоятельно, содержащий 
// функцию соединения строк и 
// функцию инвертирования строк.ы
#include "mystring.h" 

void main()
{
   char slovo[81], sp[81], c = ' ', *ptr = slovo;

   sp[0] = '\0'; // Очистка массива для нового предложения.

   cout &lt;&lt; "Enter string with point of the end:\n";
   do
   { 
      cin &gt;&gt; slovo ; // Читается слово из входного потока.
      invert(slovo); // Инвертировать слово.
      c = slovo[0];

      // Убрать точку в начале последнего слова.
      if (c == '.')
		  ptr = &amp;slovo[1];

      if (sp[0] != '\0')
           conc(sp," \0"); // Пробел перед словом.
      conc(sp,ptr);        // Добавить слово в предложение.

    }while (c != '.');    // Конец цикла чтения.

   conc(sp,".\0");         // Точка o конце предложения.
   cout &lt;&lt; "\n" &lt;&lt; sp;     // Вывод результата.
}
</example>
<p>Заголовочный файл mystring.h: </p>
<example>
void invert (char *e)
{
   char s;
   for (int m=0;e[m]!='\0';m++);
   for (int i=0,j=m-1;i &lt; j;i++,j--)
   { 
	   s = e[i];
	   e[i] = e[j];
	   e[j] = s; 
   }
}

void conc (char *c1, char *c2)
{
   for (int m=0;c1[m]!='\0';m++);
   // m - длина первой строки.
   for (int i=0; c2[i]!='\0';i++)
      c1[m+i]=c2[i];
   c1[m+i] = '\0';
}
</example>
<h5>Комментарий к коду.</h5> 
<ul>
<li>В программе в символьный массив <b>slovo</b> считывается из входного потока (с клавиатуры) очередное слово.</li>
<li><b>sp</b> - формируемое предложение, в конец которого всегда добавляется точка.</li>
<li>Переменная <b>char c</b> - первый символ каждого инвертированного слова.</li>
<li>Для последнего слова предложения этот символ равен точке.</li>
<li>При добавлении этого слова к новому предложению точка отбрасывается с помощью изменения значения указателя <b>ptr</b>. </li>
<li>Использованы директивы <b>#include</b>, включающие в программу средства ввода/вывода и тексты функций инвертирования строки <b>invert()</b> и конкатенации строк <b>conc()</b>.</li>
<li>Обратите внимание, что длина массива - первого из параметров функции conc() должна быть достаточно велика, чтобы разместить результирующую строку. </li>
<li>Препроцессор добавляет тексты всех функций в программу из файла <b>mystring.h</b> и как единое целое передает на компиляцию. </li>
</ul>
<tip start="Примечание"> Кстати, для того, что бы добавить к проекту заголовочный файл, необходимо произвести все те же действия, что и при добавлении основного файла, но при выборе типа файла следует остановиться на шаблоне Header File (.h) </tip> 
</lesson>
