<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №18" next="section3.xml" prev="section1.xml" summ="0">	  

<h2>Определение констант с помощью #define.</h2>
<p>Оператор <b><i>#define</i></b> часто используют для определения <b><i>символических констант</i></b>. Он может появиться в любом месте исходного файла, а даваемое им определение имеет силу, начиная с места появления и до конца файла. </p>
<tip start="Примечание">В конце определения символической константы (в конце оператора #define) точка с запятой не ставится!</tip>
<h5>Пример 1.</h5> 
<example>
# define min 1
# define max 100
</example>
<p>В тексте программы вместо констант 1 и 100 можно использовать соответственно <b>min</b> и <b>max</b>. </p> 
<h5> Пример 2. </h5>
<example>
#include &lt;iostream&gt;
using namespace std;
#define NAME "Vasya Pupkin."
void main ()
{
    cout &lt;&lt; " My name is " &lt;&lt; NAME;
}
Результат работы: 
My name is Vasya Pupkin.

</example>
<tip start="Примечание">Текст внутри строк, символьные константы и комментарии не подлежат замене, т.к. строки и символьные константы являются неделимыми лексемами языка C. Так что, после макроопределения <example>#define YES 1</example> в операторе <example>cout &lt;&lt; "YES";</example> не будет сделано никакой макроподстановки. </tip>
<p>Замены в тексте можно отменять с помощью команды: </p>
<example>#undef &lt;имя&gt;</example>
<p>После выполнения такой директивы имя для препроцессора становится неопределенным и его можно определять повторно. Например, не вызовут предупреждающих сообщений директивы: </p>
<example>
#define M 16
#undef M
#define M 'C'
#undef M
#define M "C"
</example>
<p>Директиву<b><i> #undef</i></b> удобно использовать при разработке больших программ, когда они собираются из отдельных "кусков текста", написанных в разное время или разными программистами. В этом случае могут встретиться одинаковые обозначения разных объектов. Чтобы не изменять исходных файлов, включаемый текст можно "обрамлять" подходящими директивами <b><i>#define</i></b> - <b><i>#undef</i></b> и тем самым устранять возможные ошибки. Например: </p>
<example>
.   .   .   .   .
     A = 10; //Основной текст.
   .   .   .   .   .
   #define A X
   .   .   .   .   .
     A = 5; //Включенный текст.
   .   .   .   .   .
   #undef A
   .   .   .   .   .
     B = A; //Основной текст.
   .   .   .   .   .
</example>
<p>При выполнении программы <b>B</b> примет значение 10, несмотря на наличие оператора присваивания <b>A=5;</b> во включенном тексте. </p>
<p>Если <b><i>строка_лексем</i></b> оказывается слишком длинной, то ее можно продолжить в следующей строке текста программы. Для этого в конце продолжаемой строки помещается символ "\". В ходе одной из стадий препроцессорной обработки этот символ вместе с последующим символом конца строки будет удален из программы. Например:</p>
<example>
#define STROKA "\n Multum, non multa - \
    mnogoe, no nemnogo!"
   .   .   .   .   .
   cout &lt;&lt; STROKA;
   .   .   .   .   .

На экран будет выведено: 

   Multum, non multa - mnogoe, no nemnogo!
</example>
<p>Напоминаем вам, что с помощью директивы #define мы с вами также создавали макросы, когда изучали встраивание в уроке номер девять. Рекомендуем Вам вернуться к этому уроку и повторить пройденный материал.</p>
</lesson>
