<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №18" next="section5.xml" prev="section3.xml" summ="1">
<h2>Другие директивы препроцессора. </h2>
<p>Кроме уже известных нам, существует несколько дополнительных директив, вот некоторые из них:</p>
<p>1. Для нумерации строк можно использовать директиву: </p>
<example>     #line &lt;константа&gt;</example>
<p>которая указывает компилятору, что следующая ниже строка текста имеет номер, определяемый целой десятичной константой. Команда может определять не только номер строки, но и имя файла: </p>
<example> #line &lt;константа&gt; "&lt;имя_файла&gt;"</example>
<p>2. Директива  </p>
<example>#error &lt;последовательность_лексем&gt;</example>
<p>приводит к выдаче диагностического сообщения в виде последовательности лексем. Естественно применение директивы<b> #еrror</b> совместно с условными препроцессорными командами. Например, определив некоторую препроцессорную переменную<b> NAME</b> </p>
<example>#define NAME 5</example>
<p>в дальнейшем можно проверить ее значение и выдать сообщение, если у <b>NAME</b> другое значение: </p>
<example>
#if (NAME != 5)
#error NAME должно быть равно 5!
</example>
<p>Сообщение будет выглядеть так: </p>
<example>
fatal: &lt;имя_файла&gt; &lt;номер_строки&gt;
#error directive: NAME должно быть равно 5!
</example>
<p>3. Команда</p>
<example>#pragma &lt;последовательность_лексем&gt;</example>
<p>определяет действия, зависящие от конкретной реализации компилятора, и позволяет выдавать компилятору различные инструкции.</p>
<p>4. В языке С существует возможность работы с операторами # и ##. Данные операторы используются в альянсе с директивой #define.</p>
<ul>
<li>Оператор # превращает аргумент, которому он предшествует, в строку, заключенную в кавычки.</li>
<example>
#include &lt;iostream&gt;
using namespace std;
# define mkstr(s) #s
void main()
{
	cout&lt;&lt;mkstr(I love C);
	// Для компилятора cout&lt;&lt;"I love C";
}
</example>
<li>Оператор ## используется для конкатенации (объединения) двух лексем</li>
<example>
#include &lt;iostream&gt;
using namespace std;
# define concat(a,b) a##b
void main()
{
	int xy=10;
	cout&lt;&lt;concat(x,y);
	// Для компилятора cout&lt;&lt;xy;
}
</example>
</ul>
<p>В языке С существуют встроенные (заранее определенные) макроимена, доступные препроцессору во время обработки. Они позволяют получить следующую информацию: </p>
<center><img src="images\1.jpg"></img></center>
</lesson>
