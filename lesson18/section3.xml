<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №18" next="section4.xml" prev="section2.xml" summ="0">
<h2>Условная компиляция.</h2>
<p>Директивы условной компиляции, позволяют генерировать программный код в зависимости от выполнимости определенных условий. Условная компиляция обеспечивается в языке C набором команд, которые, по существу, управляют не компиляцией, а препроцессорной обработкой: </p>
<example>
<b>#if</b> &lt;константное_выражение&gt;
<b>#if</b>def &lt;идентификатор&gt;
<b>#if</b>ndef &lt;идентификатор&gt;
<b>#else</b>
<b>#endif</b>
 <b>#elif</b>
</example>
<p>Первые три команды выполняют проверку условий, две следующие - позволяют определить диапазон действия проверяемого условия. Последняя команда используется для организации проверки серии условий. Общая структура применения директив условной компиляции такова: </p>
<example>
<b>#if</b>/<b>#ifdef</b>/#ifndef &lt;константное_выражение или идентификатор&gt;
          &lt;текст_1&gt;
<b>#else</b> //необязательная директива
          &lt;текст_2&gt;
<b>#endif</b>
</example>
<ul><li>Конструкция<b> <b>#else</b> &lt;текст_2&gt;</b> не обязательна. </li>
<li><b>Текст_1</b> включается в компилируемый текст только при истинности проверяемого условия. </li>
<li>Если условие ложно, то при наличии директивы <b><b>#else</b></b> на компиляцию передается <b>текст_2.</b> </li>
<li>Если директива <b><b>#else</b></b> отсутствует, то весь текст от <b><b>#if</b></b> до <b><b>#endif</b></b> при ложном условии опускается. </li>
</ul>
<p>Различие между формами команд <b><b>#if</b></b> состоит в следующем. </p>
<p>1. В первой из перечисленных директив <b>#if</b> проверяется значение константного целочисленного выражения. Если оно отлично от нуля, то считается, что проверяемое условие истинно. Например, в результате выполнения директив: </p>
<example>
<b>#if</b> 5+12
       &lt;текст_1&gt;
<b>#endif</b>
</example>
<p>текст_1 всегда будет включен в компилируемую программу. </p>
<p>2. В директиве <b>#ifdef</b>проверяется, определен ли с помощью команды <b>#define</b> к текущему моменту идентификатор, помещенный после <b>#ifdef</b>. Если идентификатор определен, то текст_1 используется компилятором. </p>
<p>3. В директиве <b>#ifndef </b>проверяется обратное условие - истинным считается неопределенность идентификатора, т.е. тот случай, когда идентификатор не был использован в команде <b>#define</b> или его определение было отменено командой <b>#undef</b>. </p>
<p>Для организации мульти ветвлений во время обработки препроцессором исходного текста программы введена директива </p>
<example> <b>#elif</b> &lt;константное_выражение&gt;</example>
<p>является сокращением конструкции <b>#else</b> <b>#if</b>. </p>
<p>Структура исходного текста с применением этой директивы такова: </p>
<example>
     <b>#if</b> &lt;константное_выражение_1&gt;
          &lt;текст_1&gt;
     <b>#elif</b> &lt;константное_выражение_2&gt;
          &lt;текст_2&gt;
     <b>#elif</b> &lt;константное_выражение_3&gt;
          &lt;текст_3&gt;
     .   .   .   .
     <b>#else</b>
          &lt;текст_N&gt;
     <b>#endif</b>
</example>
<ul>
<li>Препроцессор проверяет вначале условие в директиве <b>#if</b>, если оно ложно (равно 0) - вычисляет <b><i>константное_выражение_2</i></b>, если оно равно О - вычисляется <b><i>константное_выражение_3</i></b> и т.д. </li>
<li>Если все выражения ложны, то в компилируемый текст включается текст для случая <b>#else</b>. </li>
<li>В противном случае, т.е. при появлении хотя бы одного истинного выражения (в <b>#if</b> или в <b>#elif</b>), начинает обрабатываться текст, расположенный непосредственно за этой директивой, а все остальные директивы не рассматриваются. </li>
<li>Таким образом, препроцессор обрабатывает всегда только один из участков текста, выделенных командами условной компиляции. </li>
</ul>
<p>A, теперь, рассмотрим несколько примеров. </p>
<hr/>
<p><b>Пример 1. Простая директива условного включения. </b></p>
<example>
#ifdef ArrFlg
      int Arr[30];
   #endif
</example>
<p>Если во время интерпретации директивы определено макроопределение ArrFlg, то приведенная запись дает генерацию выражения </p>
<example>   int Arr[30];</example>
<p>В противном случае не будет генерировано ни одно выражение. </p>
<hr/>
<p><b>Пример 2. </b></p>
<example>
#include &lt;iostream&gt;
using namespace std;
#define ArrFlg 1
void main ()
{
   #ifdef ArrFlg
       int Arr[30];
   #else
       cout &lt;&lt; "Array is not defined!";
   #endif
}

</example>
<hr/>
<p><b>Пример 3. Директива условного включения с альтернативой </b></p>
<example>
#if a+b==5
      cout &lt;&lt; 5;
   #else
      cout &lt;&lt; 13;
   #endif
</example>
<p>    Если выражение <b>a+b==5</b> представляет величину, отличную от 0, то будет сгенерирована команда <b>cout &lt;&lt; 5;</b>, в противном случае будет сгенерирована команда <b>cout &lt;&lt; 13;.</b> </p>
<hr/>
<p><b>Пример 4. Составная директива условного включения </b></p>
<example>
#include &lt;iostream&gt;
using namespace std;
//++++++++++++++++++++++
#define Alfa 5
//++++++++++++++++++++++
#if Alfa*5&gt;20
      void main ()
	//++++++++++++++++++++++
	#if Alfa==4
		int Arr[2];
	#elif Alfa==3
		char Arr[2];
	#else
		{
	#endif
	//++++++++++++++++++++++
	#if 0
		cout&lt;&lt;"One";
	#else
		cout&lt;&lt;"Two";
	#endif
//++++++++++++++++++++++
#else
   cout&lt;&lt;"Test";
#endif
//++++++++++++++++++++++
}
</example>
<p>Интерпретация приведенной записи приведет к генерации </p>
<example>
void main ()
   {
      cout&lt;&lt;"Kaja";
   }
</example>
</lesson>