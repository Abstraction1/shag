<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №12: Указатели" next="section5.xml" prev="section2.xml" summ="0">
<h2>Указатели и массивы</h2>
<p>В языке C существует сильная взаимосвязь между указателями и массивами , настолько сильная, что указатели и массивы действительно следует рассматривать одновременно. Любую операцию, которую можно выполнить с помощью индексов массива, можно сделать и с помощью указателей. Вариант с указателями обычно оказывается более быстрым, но и несколько более трудным для непосредственного понимания, по крайней мере для начинающего. Описание
<example>int a[10];</example>
определяет массив размера 10, т.е. набор из 10 последовательных объектов, называемых <b>a[0], a[1], ..., a[9]</b>. Запись <b>a[i]</b> соответствует элементу массива через <b>i</b> позиций от начала. Если <b>pa</b> - указатель целого, описанный как
<example>int *pa;
</example>то присваивание
<example>pa = &amp;a[0]</example>приводит к тому, что <b>pa</b> указывает на нулевой элемент массива <b>a</b>. Это означает, что <b>pa</b> содержит адрес элемента <b>a[0]</b>. Теперь присваивание
<example>x = *pa
</example>будет копировать содержимое <b>a[0]</b> в <b>x</b>. 
</p>
<p>Если <b>ра</b> указывает на некоторый определенный элемент массива <b>a</b>, то по определению <b>pa+1</b> указывает на следующий элемент, и вообще <b>pa-i</b> указывает на элемент, стоящий на <b>i</b> позиций до элемента, указываемого <b>pa</b>, а <b>pa+i</b> на элемент, стоящий на <b>i</b> позиций после. Таким образом, если <b>pa</b> указывает на <b>a[0]</b>, то
<example>*(pa+1)</example>
ссылается на содержимое <b>a[1]</b>, <b>pa+i</b> - адрес <b>a[i]</b>, а <b>*(pa+i)</b> - содержимое <b>a[i]</b>. 
</p>
<p>Эти замечания справедливы независимо от типа переменных в массиве <b>a</b>. Суть определения "добавления 1 к указателю", а также его распространения на всю арифметику указателей, состоит в том, что приращение масштабируется размером памяти, занимаемой объектом, на который указывает указатель. Таким образом, <b>i</b> в <b>pa+i</b> перед прибавлением умножается на размер объектов, на которые указывает <b>pa</b>.</p>

<p>Очевидно существует очень тесное соответствие между индексацией и арифметикой указателей. В действительности компилятор преобразует ссылку на массив в указатель на начало массива. В результате этого имя массива является указательным выражением. Отсюда вытекает несколько весьма полезных следствий. Так как имя массива является синонимом местоположения его нулевого элемента, то присваивание <example>pa = &amp;a[0]</example> можно записать как <b>pa = a</b>.</p>

<p>Еще более удивительным, по крайней мере на первый взгляд, кажется тот факт, что ссылку на <b>a[i]</b> можно записать в виде <b>*(a+i)</b>. При анализировании выражения <b>a[i]</b> в языке C оно немедленно преобразуется к виду <b>*(a+i);</b> эти две формы совершенно эквивалентны. Если применить операцию <b>&amp;</b> к обеим частям такого соотношения эквивалентности, то мы получим, что <b>&amp;a[i]</b> и <b>a+i</b> тоже идентичны: <b>a+i</b> - адрес <b>i-го</b> элемента от начала <b>a</b>. С другой стороны, если <b>pa</b> является указателем, то в выражениях его можно использовать с индексом: <b>pa[i]</b> идентично <b>*(pa+i)</b>. Короче, любое выражение, включающее массивы и индексы, может быть записано через указатели и смещения и наоборот, причем даже в одном и том же утверждении.</p>

<p>Имеется одно различие между именем массива и указателем, которое необходимо иметь в виду. Указатель является переменной, так что операции <b>pa=a</b> и <b>pa++</b> имеют смысл. Но имя массива является константой, а не переменной: конструкции типа <b>a=pa</b> или <b>a++</b>,или <b>p=&amp;a</b> будут незаконными.</p>

<p>Когда имя массива передается функции, то на самом деле ей передается местоположение начала этого массива. Внутри вызванной функции такой аргумент является точно такой же переменной, как и любая другая, так что имя массива в качестве аргумента действительно является указателем, т.е. переменной, содержащей адрес.
<example>
 /* показывает на экран массив m */
  void ShowElements(int *m, int size)
  {
      int n; 
      for (n = 0; n &lt; size; m++,n++)
              cout&lt;&lt;*m&lt;&lt;"\t";
   
  }
</example>
Операция увеличения m совершенно законна, поскольку эта переменная является указателем, <b>m++</b> никак не влияет на массив в обратившейся к <b>ShowElements</b> функции, а только увеличивает локальную для функции <b>ShowElements</b> копию адреса.
</p>
<p>Описания формальных параметров в определении функции в виде
<example>int m[];
</example>и
<example>int *m;
</example>совершенно эквивалентны; какой вид описания следует предпочесть, определяется в значительной степени тем, какие выражения будут использованы при написании функции. Если функции передается имя массива, то в зависимости от того, что удобнее, можно полагать, что функция оперирует либо с массивом, либо с указателем, и действовать далее соответвующим образом. Можно даже использовать оба вида операций, если это кажется уместным и ясным. 
</p>

</lesson>