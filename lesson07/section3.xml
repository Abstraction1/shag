<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №7" next="section5.xml" prev="section2.xml" summ="0">

<h2>Двумерные массивы, как частный случай многомерных массивов.</h2>
<p>
Мы с вами уже имеем понятие о том, что такое массивы, в прошлом уроке мы разобрали так называемый - одномерный массив. Одномерный массив - массив данных, где каждое значение обладает только одной характеристикой - порядковым номером (индексом). Именно по этому индексу мы и обращаемся к конкретному элементу.
</p>

<p>
Сегодня мы поговорим о многомерных массивах, т. е. о массивах, где каждый элемент описывается несколькими характеристиками. Примером значения многомерного массива может являться, что угодно:
</p>

<p>
1. Шахматная доска - каждая клетка имеет две размерности E2 (буква и цифра)
</p>

<p>
2. Оценка КВН - три размерности ЧЛЕН_ЖЮРИ, КОНКУРС, КОМАНДА.
</p>

<p>
Максимальная размерность массива допустимая в С - . Мы с вами остановимся на двумерном массиве, второе название которого матрица.
</p>

<h3>Двумерный массив.</h3>
<h5>Объявление и расположение в памяти.</h5>

<p>
Двумерный массив представляет собой совокупность строк и столбцов, на пересечении которых находится конкретное значение. 
Объявить двумерный массив несложно, необходимо указать количество строк и столбцов. При этом, здесь действуют все теже правила, что и при объявлении одномерного массива. Т. е. нельзя в качестве количества строк и столбцов указывать неконстантные и нецелочисленные значения.
</p>

<example>
Общий синтаксис:

	тип_данных имя_массива [число_строк][число_столбцов];

Пример:
	const int row=3; // строки
	const int col=4; // столбцы
	int array[row][col]; // массив размером row на col(3х4)
</example>
<center><img src="images\2.jpg"></img></center>
<p>
Несмотря на то, что мы представляем массив в виде матрицы, на самом деле - любой двумерный массив располагается в памяти построчно: сначала нулевая строка, затем первая и так далее. Об этом следует помнить, т. к. выход за пределы массива может повлечь за собой некорректную работу программы, при этом не выдав ошибки.
</p>
<center><img src="images\3.jpg"></img></center>
<h5>Инициализация.</h5>

<p>
Инициализация двумерного массива также аналогична инициализации одномерного:
</p>

<p>
1. Инициализация при создании.
</p>

<example>

Каждая строка заключается в отдельные фигурные скобки:

	int array[2][2]={{1,2},{7,8}};

Значения указываются подряд и построчно вписываются в массив:

	int array[2][2]={7,8,10,3};

Если значение пропущенно, оно будет инициализированно нулем:

	int array[3][3]={{7,8},{10,3,5}};

</example>

<p>
2. Инициализация c помощью цикла. 
</p>

<p>
Откроем один секрет - двумерный массив можно рассматривать как совокупность, не просто строк, а одномерных массивов. То есть, один одномерный массив, мы заполняем простым циклом, перебирая конкретные элементы, а при совокупности, нам необходимо перебирать еще и отдельные массивы.
</p>


<example>
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt; // в этом файле содержатся функции rand и srand
#include&lt;time.h&gt; // в этом файле содержится функция time
using namespace std;
void main()
{

	const int row=3; // строки
	const int col=3; // столбцы
	int mr[row][col]; // массив размером row на col

	// перебираем отдельные строки (одномерные массивы в совокупности)
	for(int i=0; i&lt;row; i++)
	{
		// перебираем отдельные элементы каждой строки
		for(int j=0; j&lt;col;j++)
		{
			// инициализация элементов значениями в диапазоне от 0 до 100
			mr[i][j]=rand()%100;
			
			// показ значений на экран
			cout&lt;&lt;mr[i][j]&lt;&lt;" ";
		}
		
		// переход на другую строку матрицы
		cout&lt;&lt;"\n\n";
        }

}
</example>
<tip start="Примечание">Обращение к конкретному элементу массива производится по номеру строки и номеру столбца, например - mr[2][1] - значение, лежащее на пересечении второй строки и первого столбца.</tip>
<hr/>
<p>Работа с двумерным массивом не намного сложнее, чем с одномерным - докажем это на практике.</p>
</lesson>