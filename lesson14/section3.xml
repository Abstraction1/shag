<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №14" next="section4.xml" prev="section2.xml" summ="0">
<h2>Работа со строками в С. Примеры.</h2>
<p>Предыдущая тема урока была посвящена строковым функциям, эта тема посвящается работе с ними.</p>
<h3>Определение длины строк.</h3>

<p>Длина строки определяется просто. Для этого нужно передать строковый указатель функции <b>strlen()</b>, которая возвратит длину строки, выраженную в символах. После объявления </p>
<example>
char *с = "Any old string....";
int len;
</example>
<p>следующий оператор установит переменную <b>len</b> равной длине строки, адресуемой указателем <b>с</b>:</p>
<example>
len = strlen(с);
</example>
<p>пример использования функции strlen().</p>
<example>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
using namespace std;
const int MAXLEN=256;
void main()
{
	char string[MAXLEN]; /* Место для 255 символов. */
	cout &lt;&lt; "Input string:: ";
	gets(string);
	cout &lt;&lt;"\n";/* Начать новую строку. */
	cout &lt;&lt; "String: " &lt;&lt; string &lt;&lt; "\n";
	cout &lt;&lt; "Length = " &lt;&lt; strlen(string);
}
</example>
<p>Здесь определяется строковая переменная с именем <b>string</b> для приема ввода от функции <b>gets()</b>. После того как вы введете строку, программа передаст переменную <b>string</b> функции <b>strlen()</b>, которая вычислит длину строки в символах.</p>
<p>В функцию <b>strlen()</b> можно передавать и другие виды строк. Например, вы можете определить и инициализировать символьный буфер следующим образом:</p>
<example>char buffer[128] = "Copy in buffer";</example>
<p>Затем используйте функцию <b>strlen()</b> для установки целой переменной <b>len</b>, равной числу символов в литеральной строке, скопированной в буфер:</p>
<example>
int len;	/* Определить целую переменную. */
len = strlen(buffer); /* Вычислить длину строки. */
</example>
<h3>Копирование строк.</h3>
<p>Оператор присваивания для строк не определен. Если с1 и с2 - символьные массивы, вы не сможете скопировать один в другой следующим образом:</p>
<example>с1 = с2; //???</example>
<p>Но если <b>с1</b> и <b>с2</b> объявить как указатели типа <b>char *</b>, компилятор согласится с этим оператором, но вряд ли вы получите ожидаемый результат. Вместо копирования символов из одной строки в другую оператор <b>с1 = с2 скопирует указатель с2 в указатель с1</b>, перезаписав, таким образом, адрес в <b>с1</b>, потенциально потеряв информацию, адресуемую указателем.</p>
<p>Чтобы скопировать одну строку в другую, вместо использования оператора присваивания вызовите функцию копирования строк <b>strcpy()</b>. Для двух указателей <b>с1</b> и <b>с2</b> типа <b>char *</b> оператор</p>
<example>strcpy(с1, с2);</example>
<p>копирует символы, адресуемые указателем <b>с2</b>, в память, адресуемую указателем <b>с1</b>, включая завершающие нули. И только на вас лежит ответственность за то, что принимающая строка будет иметь достаточно места для хранения копии.</p>
<p>Аналогичная функция <b>strncpy()</b> ограничивает количество копируемых символов. Если источник <b>(source)</b> и приемник <b>(destination)</b> являются указателями типа <b>char *</b> или символьными массивами, то оператор</p>
<example>strncpy(destination, source, 10);</example>
<p>скопирует до 10 символов из строки, адресуемой указателем <b>source</b>, в область памяти, адресуемую указателем <b>destination</b>. Если строка <b>source</b> имеет больше 10 символов, то результат усекается. Если же меньше - неиспользуемые байты результата устанавливаются равными нулю.</p>
<tip start="Примечание">Строковые функции, в имени которых содержится дополнительная буква n, объявляют числовой параметр, ограничивающий некоторым образом действие функции. Эти функции безопаснее, но медленнее, чем их аналоги, не содержащие букву n. Программные примеры содержат следующие пары функций: <b>strcpy()</b> и <b>strncpy()</b>, <b>strcat()</b> и <b>strncat()</b>, <b>strcmp()</b> и <b>strncmp()</b>. </tip>
<h3>Конкатенация строк.</h3>
<p><b>Конкатенация двух строк означает их сцепление</b>, при этом создается новая, более длинная строка. При объявлении строки</p>
<example>char original[128] = "Test ";</example>
<p>оператор</p>

<example>strcat(original, " one, two, three!");</example>
<p>превратит значение первоначальной строки <b>original</b> в "Test one, two, three!" </p>
<p>При вызове функции <b>strcat()</b> убедитесь, что первый аргумент типа <b>char *</b> инициализирован и имеет достаточно места, чтобы запомнить результат. Если <b>c1</b> адресует строку, которая уже заполнена, а <b>c2</b> адресует ненулевую строку, оператор <b>strcat(c1, c2);</b> перезапишет конец строки, вызвав серьезную ошибку.</p>
<p>Функция strcat() возвращает адрес результирующей строки (совпадающий с ее первым параметром) и может использоваться как каскад нескольких вызовов функций:</p>
<example>strcat(strcat(c1,c2),c3)</example>
<p> Следующий пример показывает, как можно использовать функцию <b>strcat()</b> для получения в одной строке фамилии, имени и отчества, хранящихся отдельно, например, в виде полей базы данных. Введите фамилию, имя и отчество. Программа сцепит введенные вами строки и отобразит их как отдельную строку.</p>
<example>
#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
void main()
{
	//Резервирование места для ввода трех строк.
  	char *fam = new char[128];
  	char *im = new char[128];
  	char *otch = new char[128];
 	//Ввод данных.
 	cout &lt;&lt; "Enter" &lt;&lt; "\n";
 	cout &lt;&lt; "\tSurname: ";
 	cin &gt;&gt; fam;
 	cout &lt;&lt; "\tName: ";
 	cin &gt;&gt; im;
  	cout &lt;&lt; "\tLastname: ";
  	cin &gt;&gt; otch;
 	 //Резервирование места для результата.
  	//Нужно учесть два пробела и результирующий
 	//нулевой символ.
  	char *rez=new char[strlen(fam)+strlen(im)+strlen(otch)+3];
  	//"Сборка" результата.  
  	strcat(strcat(strcpy(rez,fam)," "),im);
  	strcat(strcat(rez," "),otch);
  	//Возврат памяти в кучу.
  	delete [] fam;
 	delete [] im;
 	delete [] otch;
 	//Вывод результата.
  	cout &lt;&lt; "\nResult: " &lt;&lt; rez;
  	delete [] rez;
}

</example>
<p>Приведенная программа демонстрируют важный принцип конкатенации строк: всегда инициализируйте первый строковый аргумент. В данном случае символьный массив <b>rez</b> инициализируется вызовом функции <b>strcpy()</b>, которая вставляет <b>fam</b> в <b>rez</b>. После этого программа добавляет пробелы и две другие строки - <b>im</b> и <b>otch</b>. Никогда не вызывайте функцию <b>strcat()</b> с неинициализированным первым аргументом.</p>
<p>Если вы не уверены в том, что в строке достаточно места для присоединяемых подстрок, вызовите функцию <b>strncat()</b>, которая аналогична функции <b>strcat()</b>, но требует числового аргумента, определяющего число копируемых символов. Для строк <b>s1</b> и <b>s2</b>, которые могут быть либо указателями типа <b>char *</b>, либо символьными массивами, оператор</p>
<example>strncat(s1, s2, 4);</example>
<p>присоединяет максимум четыре символа из <b>s2</b> в конец строки <b>s1</b>. Результат обязательно завершается нулевым символом.</p>
<p>Существует один способ использования функции <b>strncat()</b>, гарантирующий безопасную конкатенацию. Он состоит в передаче функции <b>strncat()</b> размера свободной памяти строки-приемника в качестве третьего аргумента. Рассмотрим следующие объявления: </p>
<example>
const int MAXLEN=128 
char s1[MAXLEN] = "Cat";
char s2[] = "in hat";
</example>
<p>Вы можете присоединить <b>s2</b> к <b>s1</b>, формируя строку <b><i>"Cat in hat"</i></b>, с помощью функции <b>strcat()</b>:</p>
<example>strcat(s1, s2);</example>
<p> Если вы не уверены, что в <b>s1</b> достаточно места, чтобы запомнить результат, используйте альтернативный оператор:</p>
<example>strncat(s1, s2, (MAXLEN-1)-strlen(s1));
</example>
<p>Этот способ гарантирует, что <b>s1</b> не переполнится, даже если <b>s2</b> нужно будет урезать до подходящего размера. Этот оператор прекрасно работает, если <b>s1</b> - нулевая строка.</p>
<p>Часто программам приходится выполнять поиск в строках отдельных символов или подстрок, особенно при проверке имен файлов на заданное расширение. Например, после того как пользователю предложили ввести имя файла, проверяется, ввел ли он расширение <b>.ТХТ</b>, и если это так, то выполняется действие, отличное от того, какое было бы выполнено для расширения <b>.ЕХЕ</b>.</p>
<p>Возможно, вы также захотите отвергнуть все расширения, кроме определенного, что поможет вам предотвратить ошибки, вызванные загрузкой файла данных нежелаемого типа.</p>
<h3>Поиск символов.</h3>
<p>Пример использования функции <b>strchr()</b>. </p>
<example>
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
using namespace std;
void main()
{
  char *filename = new char[128];
  cout &lt;&lt; "Enter name of file: ";
  gets(filename);
  cout &lt;&lt; "\nName of file: " &lt;&lt; filename &lt;&lt; "\n";
  if (strchr (filename,'.'))
     cout &lt;&lt; "Name has extension" &lt;&lt; "\n";
  else
     strcat (filename,".TXT");
  cout &lt;&lt; "Name of file: " &lt;&lt; filename &lt;&lt; "\n";
  delete [] filename;
}
</example>
<p>Данная программа находит расширение в имени файла, выполняя поиск точки среди символов введенной строки. (В имени файла может быть только одна точка, которая должна предшествовать расширению, если оно имеется.) Ключевым в этой программе является оператор </p>
<example>
if (strchr (filename,'.'))
     cout &lt;&lt; "Name has extension" &lt;&lt; "\n";
else
     strcat (filename,".TXT");
</example>
<p>Выражение <b>strchr (filename,'.')</b> возвращает указатель на символ точки в строке, адресуемой указателем <b>filename</b>. Если такой символ не найден, функция <b>strchr()</b> возвращает нуль. Поскольку ненулевые значения означают "истину", вы можете использовать функцию <b>strchr()</b> в качестве возвращающей значение "истина"/"ложь". Вы также можете применить функцию <b>strchr()</b> для присваивания указателя на подстроку, начинающуюся с заданного символа. Например, если <b>р</b> - указатель, объявленный как <b>char *</b>, и указатель <b>filename</b>  адресует строку <b>TEST.ТХТ</b>, то результат действия оператора <b>p=strchr(filename, '.');</b> показан на рисунке </p>
<center><img src="images\7.jpg"></img></center>
<p>Рисунок демонстрирует еще один важный момент, связанный с адресацией указателем не полной строки, а ее части - подстроки. Такими указателями следует пользоваться с большой осторожностью. На рисунке показана только одна строка, <b>TEST.ТХТ</b>, оканчивающаяся нулевым байтом, но два указателя - <b>filename</b> и <b>p</b>. Указатель <b>filename</b> адресует полную строку. А указатель <b>p</b> адресует подстроку внутри того же набора символов. Строковые функции не заботятся о байтах, которые предшествуют их первому символу. Поэтому оператор </p>
<example>puts(p);</example>
<p>отображает подстроку<b> .ТХТ</b> так, будто она полная строковая переменная, а не часть другой строки.</p>
<p>В программировании на C нет ничего необычного в использовании многих указателей, адресующих подстроки одной и той же полной строки. Но строка, показанная на рисунке, расположена в куче, поэтому оператор </p>
<example>delete [] p;</example>
<p>пытаясь тем самым освободить подстроку, адресуемую указателем <b>p</b>, что, несомненно, приведет к разрушению кучи, вызвав ошибку, относящуюся к разряду трудно обнаруживаемых.</p>
<p>Функция <b>strchr()</b> отыскивает первое появление символа в строке. Объявления и операторы </p>
<example>
char *p;
char s[]="Abracadabra";
 p = strchr(s,'a');
</example>
<p>присваивают указателю <b>p</b> адрес первой строчной буквы 'а' в строке "Abracadabra". </p>
<p>Функция <b>strchr()</b> рассматривает завершающий нуль строки как значащий символ. Приняв во внимание этот факт, можно узнать адрес конца строки. Учитывая предыдущие объявления, оператор </p>
<example>p = strchr(s,0);</example>
<p>установит указатель <b>p</b> равным адресу подстроки "bra" в конце строки "Abracadabra". </p>

<h3>Поиск подстрок.</h3>
<p>Кроме поиска символов в строке, вы также можете поохотиться и за подстроками. Этот пример демонстрирует этот метод. Данная программа аналогична предыдущей, но устанавливает расширение файла <b>.ТХТ</b>.</p>
<example>
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
using namespace std;
void main()
{
  char *filename = new char[128],*p;
  cout &lt;&lt; "Enter name of file: ";
  gets(filename);
  cout &lt;&lt; "\nName of file: " &lt;&lt; filename &lt;&lt; "\n";
  strupr(filename);
  p = strstr (filename,".TXT");
  if (p)
     cout &lt;&lt; "Name has extension" &lt;&lt; "\n";
  else
   { p = strchr (filename,'.');
     if (p) 
        *p=NULL; //Удалить любое другое расширение.
     strcat (filename,".TXT");
   }
  cout &lt;&lt; "Name of file: " &lt;&lt; filename &lt;&lt; "\n";
  delete [] filename;
}

</example>
<p>Эта программа создает имя файла, которое обязательно заканчивается расширением <b>.ТХТ</b>. Чтобы определить, есть ли в имени файла это расширение, программа выполняет оператор </p>
<example>p = strstr (filename,".TXT");</example>
<p>Подобно <b>strchr()</b>, функция <b>strstr()</b> возвращает адрес подстроки или нуль, если искомая строка не найдена. Если же цель будет обнаружена, указатель <b>p</b> установится равным ее адресу, в данном примере - адресу точки в подстроке <b>.ТХТ</b>. Поскольку расширение может быть введено и строчными буквами, программа выполняет оператор</p>
<example>strupr(filename);</example>
<p>чтобы перед вызовом функции <b>strstr()</b> преобразовать буквы оригинальной строки в прописные. </p>
<p>Пример также демонстрирует способ усечения строки в позиции заданного символа или подстроки. Здесь вызывается функция <b>strstr()</b>, чтобы установить указатель p равным адресу первой точки в строке <b>filename</b>. Если результат этого поиска не нулевой, то выполнится оператор, который запишет вместо точки нулевой байт: </p>
<example>*p = NULL;
</example>
<p>Тем самым будет присоединен новый конец строки в том месте, где раньше находилось расширение файла. Теперь строка готова к добавлению нового расширения путем вызова функции <b>strcat()</b>.</p>

</lesson>