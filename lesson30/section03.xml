<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №30" next="section04.xml" prev="section02.xml" summ="0">
<h2>Файловый ввод-вывод с применением потоков.</h2>

<p>
Итак. Вы, наверняка, согласитесь, что файл - это именованная цепочка байтов, у которой есть начало и конец. В С++ существует библиотека под названием fstream. С её помощью, можно осуществить следующие функции:
</p>

<ul>
<li>
Cоздание файла.
</li>
<li>
Cоздание потока.</li>
<li>Открытие файла.</li>
<li>"Присоединение" файла к потоку.</li>
<li>Обмен с файлом с помощью потока.</li>
<li>"Отсоединение" потока от файла.</li>
<li>Закрытие файла.</li>
<li>Уничтожение файла.</li>
</ul>

<tip start="Примечание"> Для корректной работы библиотеки fstream необходимо использовать <b>using namespace std;</b></tip>

<p>Библиотека fstream, как и библиотека iostream содержит три класса, предназначенных для ввода и вывода данных в файлы:</p>
<ul>
<li>
ofstream - для вывода (записи) данных в файл.</li>
<li>ifstream - для ввода (чтения) данных из файла.</li>
<li>fstream - для чтения и для записи данных.</li>
</ul>

<p>Для каждого из этих трех классов предусмотрено четыре конструктора. Рассмотрим их:</p>

<example>
<b>
	fstream() - создает поток, не открывая файла;

	fstream(

		const char* name, 		// имя файла
		int omode,        		// режим открытия
		int = filebuf::openprot   // защита файла

	) - создает поток, открывает файл и связывает его с потоком;

	fstream( 
		
		int f 				// дескриптор файла

	) - создает поток и связывает его с уже открытым файлом

	fstream( 
		int f,				// дескриптор файла
		char *buf,  			// буфер
		int len     			// размер буфера

	) - то же, что предыдущий конструктор, но потоку назначается буфер.
</b>
</example>

<p>Среди вышеперечисленных параметров можно выделить параметр omode. Это набор флагов для открытия файла:</p>

<example>
<b>
enum _Openmode { 
      in        = 0x01, // открыть только для чтения
      out       = 0x02, // открыть только для записи
      ate       = 0x04, // установить указатель на конец файла
      app       = 0x08, // дописывать данные в конец файла
      trunc     = 0x10, // усечь файл до нулевой длины
      _Nocreate  = 0x40, // если файл не существует, ошибка открытия
      _Noreplace = 0x80, // если файл уже существует, ошибка открытия
      binary    = 0x20  // открыть файл для двоичного обмена
};
</b>
</example>

<tip start="Примечание">Для определения флага к нему необходимо добавить ios::. Например, ios::in.</tip>

<h5>Функции для работы с файлами.</h5>

<hr/>
<example>
<b>
void open(const char *fileName, int mode = знач_по_ум,int protection = знач_по_ум);
</b>
</example>
<p>
"Присоединяет" файловый поток к конкретному файлу.
</p>
<p>
<b>
fileName</b> - имя уже существующего или создаваемого заново файла. Это строка, которая задает полное или сокращенное имя файла в формате, определенном операционной системой.
</p>

<p>
<b>
mode</b> - режим открытия.
</p>

<p>
<b>protection</b> - защита файла.
</p> 

<p>Функция вызывается через объект любого из трех потоковых классов и записывает в него нуль в случае ошибки.</p>

<hr/>
<example>
<b>
int close();
</b>
</example>

<p>Функция очищает буфер потока, отсоединяет поток от файла и закрывает файл.</p>

<tip start="Примечание">Эта функция вызывается автоматически при завершении программы.</tip>

<hr/>
<example>
<b>
istream&amp;amp; istream::read(unsigned char *buf, int len);
istream&amp;amp; istream::read(signed char *buf, int len);
</b>
</example>
<p>
Производит чтение блока символов.
</p>
<p>
<b>len</b> - максимальное число символов, которые должны быть извлечены из потока в буфер <b>buf</b>. 
</p>

<hr/>
<example>
<b>
ostream&amp;amp; osteram::write(const unsigned char *buf, int n);
ostream&amp;amp; osteram::write(const signed char *buf, int n);
</b>
</example>
<p>
Производит запись блока символов.
</p>
<p>
<b>n</b> - число символов, считая ноль-символ, которые должны быть помещены в поток из буфера <b>buf</b>.  
</p>

<hr/>
<example>
<b>
int istream::get();
istream&amp; istream::get(unsigned char&amp;);
istream&amp; istream::get(signed char&amp;);
</b>
</example>
<p>
Извлекает один символ из потока.
</p>

<example>
<b>
ostream&amp; ostream::put(char);
</b>
</example>
<p>
Помещает один символ в поток.
</p>

<example>
<b>
istream&amp; istream::get(unsigned char *buf, int n, char c = '\n');
istream&amp; istream::get(signed char *buf, int n, char c = '\n');
</b>
</example>
<p>
Извлекает строку из потока.
</p>

<p>
Во всех вышеописанных функциях символы извлекаются и помещаются в буфер пока не будет найден символ-ограничитель, или не будет прочитано n символов, или не встретится конец файла. Ограничитель из потока не извлекается и в буфер не помещается. 
</p>

<hr/>

<example>
<b>
istream&amp; istream::getline(unsigned char *buf, int n, char c = '\n');
istream&amp; istream::getline(signed char *buf, int n, char c = '\n');
</b>
</example>
<p>
Данная функция выполняет то же, что и get, но ограничитель извлекается из потока (в буфер не заносится). 
</p>

<hr/>

<example>
<b>
istream&amp; istream::ignore(int n = 1, int d = EOF);
</b>
</example>
<p>
Данная функция извлекает символы из потока, пока не встретится ограничитель d или пока не извлечет n символов. 
</p>

<hr/>

<example>
<b>
int istream::gcount();
</b>
</example>
<p>
Данная функция возвращает число символов, извлеченных последней функцией бесформатного ввода. 
</p>

<hr/>


<example>
<b>
int istream::peek();
</b>
</example>
<p>
Данная функция позволяет "взглянуть" на очередной символ входного потока - возвращает код следующего символа потока (или EOF, если поток пуст), но оставляет этот символ в потоке. При необходимости этот символ можно извлечь из потока с помощью других средств библиотеки. 
</p>

<hr/>


<example>
<b>
istream&amp; istream::putback(char cc);
</b>
</example>
<p>
Данная функция не извлекает ничего из потока, а помещает в него символ cc, который становится текущим и будет следующим извлекаемым из потока символом.  
</p>

<hr/>

<example>
<b>
istream&amp; istream::seekg(long pos);
</b>
</example>
<p>
Данная функция устанавливает позицию чтения из потока в положение, определяемое значением параметра. 
</p>

<hr/>

<example>
<b>
istream&amp; istream::seekg(long off, ios::seek_dir dir);
</b>
</example>
<p>
Данная функция выполняет перемещение позиции чтения вдоль потока в направлении, опеределенном параметром dir, который принимает значение из перечисления enum seek_dir {beg, cur, end};. Относительная величина перемещения ( в байтах) определяется значением параметра long off. Если направление определено как beg, то смещение от начала потока; cur - от текущей позиции; end - от конца потока. 
</p>

<hr/>
<example>
<b>
ostream&amp; ostream::seekp(long pos);
</b>
</example>
<p>
Данная функция устанавливает абсолютную позицию записи в поток. 
</p>

<hr/>
<example>
<b>
ostream&amp; ostream::seekp(long off, ios::seek_dir dir);
</b>
</example>
<p>
Данная функция аналогична функции seekg(), но принадлежит классу ostream и выполняет относительное перемещение записи в поток.
</p>

<hr/>

<hr/>
<example>
<b>
long istream::tellg();
</b>
</example>
<p>
Данная функция определяет текущую позицию чтения из потока.
</p>

<hr/>
<hr/>
<example>
<b>
long ostream::tellp();
</b>
</example>
<p>
Данная функция определяет текущую позицию записи в поток.
</p>

<hr/>
<p>Ну, что ж теории, пожалуй достаточно - пора переходить к практике. В следующих разделах урока мы рассмотрим несколько примеров.</p>
</lesson>