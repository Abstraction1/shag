<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №33" next="section07.xml" prev="section02.xml" summ="0">
<h2>Пространства имен и их использование. </h2>

<p>
<b>"Представьте, что Вы отправились в неизведанные земли и в пути приобрели последователей. Последователи устали и решили основать новый город на берегах великой реки. Но Вы не знаете как назвать поселение, поскольку не знакомы с другими городами этой страны и не желаете выбирать уже существующее имя. Очевидное решение - провозгласить новое государство, чтобы имя нового поселения было гарантированно уникальным в его пределах." </b>- этот пример является в специальной литературе классическим для наглядного разъяснения темы данного раздела урока. Дело в том, что в программировании точно также можно давать разным объектам одинаковые имена, разделяя их так называемыми пространствами имен пространствами имен. Познакомимся с определением:
</p>

<p>
<b>Пространство имён (namespace)</b> — в программировании именованная, либо неименованная область определения переменных, типов, констант. Пространства имён используются для отграничения набора данных и функций в один блок, чтобы исключить конфликты с другими наборами функций. Иначе говоря, пространства имен используются для разбиения области видимости на несколько зон.
</p>

<h5>Объявление пространства имен.</h5>

<p>
Синтаксис объявления пространства имен чем-то напоминает синтаксис объявления класса. Условно - это обозначение имени для области видимости, в которую будут входить компоненты пространства:
</p>

<example>

namespace имя
{
	перечень_данных;
}

</example>
  

<h5>Применение пространства имен.</h5>

<p>
Два одинаковых идентификатора в одной области видимости существовать  не могут. Например, в одной программе невозможно создать две функции fire() с одинаковыми прототипами, одна из которых зажигала бы факел, а другая производила стрельбу из пистолета, кроме как с помощью пространства имен.
</p>

<p>
Пространства имен позволяют разместить две функции в различных областях видимости, не создавая при этом проблем. Кроме того, можно разместить все функции, связанные с определённым направлением, в отдельном пространстве имен. Например, функция fire(), зажигающая факел, попадет в пространство имен exploration (исследование) наряду с другими функциями исследования, а функция fire(), ответственная за стрельбу из пистолета, попадёт в пространство имен combat (боевое).
</p>

<example>

	namespace combat{
	
		void fire(){
			cout&lt;&lt;"Vistrel";
		}

	}

	namespace exploration{
	
		void fire(){
			cout&lt;&lt;"Ogon`";
		}

	}

</example>

<p>
Для осуществления доступа к компонентам пространства имен используется оператора разрешения области видимости. Синтаксис доступа выглядит так:
</p>

<example>

	#include &lt;iostream&gt;
	using namespace std;

	namespace combat{
	
		void fire(){
			cout&lt;&lt;"Vistrel";
		}

	}

	namespace exploration{
	
		void fire(){
			cout&lt;&lt;"Ogon`";
		}

	}

	void main(){
		
		combat::fire();
		exploration::fire();
		
	}


</example>

<h5>Глобальное пространство имен.</h5>

<p>
<b>Глобальное пространство имен</b> - это название области видимости самого высокого уровня, то есть той, где существуют глобальные переменные.
</p>

<p>
Чтобы обратиться к члену глобального пространства, часто приходится пользоваться оператором разрешения области видимости (::). Это необходимо, если существуют совпадающие имена в локальном и глобальном пространствах, поскольку по умолчанию всегда выбирается переменная с наименьшей областью видимости. Синтаксис обращения к члену глобального пространства следующий:
</p>

<example>
	::глобальный_член;
</example>


<h5>Повторные объявления пространств имен.</h5>

<p>
Если два пространства имен имеют одинаковые имена, второе считается логическим продолжением первого. И компилятор считает идентичными конструкции следующего вида:
</p>

<example>

namespace x
{
	func1(){}
}

namespace x
{
	func2{}
}

и 

namespace x
{
	func1(){}
	func2(){}
}

</example>

<p>
C++ помещает оба пространства в одну область видимости при компиляции программы, это означает, что в дублирующихся пространствах имен не могут существовать члены с одинаковыми именами.
</p>

<h5>Прямой доступ к пространствам имен.</h5>

<p>
Если Вы уверены, что пространство не содержит дублирующих членов, то можете произвести слияние его с глобальным пространством имен. Благодаря этому исчезает необходимость постоянно набирать идентификатор пространства имен и оператор разрешения области видимости. Существует два метода прямого доступа к пространству имен:
</p>

<ol>
<li>
Объявление using.
</li>
<li>
директива using
</li>
</ol>

<h5>Объявление using.</h5>

<p>
Объявление using показывает, что работа, будет производиться с определенным членом области видимости более низкого уровня. В результате отпадает необходимость в явном указании области видимости. Синтаксис объявления using следующий:
</p>

<example>

	using имя_пространства::член;

Пример использования:

	namespace dragon
	{
		int gold=50;
	}

	void main()
	{
		using dragon::gold;
		cout&lt;&lt;gold;
	}

</example>


<h5>Директива using.</h5>

<p>
Директива using показывает, что работа будет производиться со всеми членами конкретного пространства имен. Директива работает также, как и объявление, с той лишь разницей, что обеспечивает прямой доступ ко всем членам пространства. Воспользовавшись ею, вы избавляетесь от необходимости уточнять имена членов этого пространства до конца программы. Перед её применением следует убедиться, что во включаемом пространстве имен отсутствуют идентификаторы, дублирующие идентификаторы глобального пространства. Синтаксис директивы using таков:
</p>

<example>

	using namespace имя_пространства;

</example>

<p>
C примером использования этой конструкции вы уже сталкивались, он присутствует во всех написанных вами программах:
</p>

<example>
	using namespace std;
</example>


<h5>Создание безымянных пространств имен.</h5>

<p>
Давайте теперь разберёмся, каким образом можно гарантировать корректность имени, присвоенного пространству. Как это ни странно - создав пространство имен без имени!!! Это связано с тем, что если создать безымянное пространство, С++ автоматически даст ему уникальное имя. Синтаксис объявления безымянного пространства имен следующий:
</p>

<example>

	namespace
	{
		члены;
	}

</example>

<p>
В такой ситуации С++ позволяет обращаться к компонентам безымянного пространства, добавляя  неявное объявление using namespace после объявления самого пространства имен. Так что код строится таким образом:
</p>

<example>

	namespace a
	{
		члены;
	}
	using namespace a;

</example>

<p>
а это уникальный идентификатор, о котором программисту ничего неизвестно. Рассмотрим пример работы с безымянным пространством имен:
</p>

<example>

	#include &lt;iostream&gt;
	using namespace std;

	namespace
	{
		void func(){cout&lt;&lt;"::func"&lt;&lt;"\n"}
	}
	void main()
	{
		::func();
	}

</example>

</lesson>