<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №33" next="section05.xml" prev="section01.xml" summ="1">
<h2>Реализация механизма. Ключевые слова try, catch, throw.</h2>
<p>
Итак, для организации механизма обработки исключений в С++ используются три ключевых слова: 
</p>

<p>

<b>try (контролировать)</b> - с помощью фигурных скобок отделяет определенную область кода, в которой может быть сгенерированно исключение 
</p>
<p>
<b>throw (бросать)</b> - оператор, который в момент возникновения исключительной ситуации генерирует исключение и выводит программу из "критического" блока.
</p>
<p>
<b>catch (поймать)</b> - оператор, который позволяет "поймать" конкретное исключение и проанализировав его выдать нужную реакцию.
</p>


<p>
Синтаксис организации механизма:
</p>

<example>

try{ 
	блок кода;
	...
	throw выражение_определенного_типа;
	...
}

catch(тип_исключения имя)
{
	блок_анализа;
}

</example>

<h5>Анализ синтаксиса.</h5>


<ol>
<li>
В одном блоке try может быть несколько throw, возбуждающих различные исключения.
</li>
<li>
Когда срабатывает throw, то с помощью выражения, находящегося в нём в памяти образуется объект, который имеет тип совпадающий с типом выражения. После его формирования throw передает управление объектом за пределы блока try. Где объект попадет в соответствующий блок catch, который также имеет схожий тип данных. Именно в catch и происходит последующий анализ.
</li>    
<li>
Блоков catch, также как и throw может быть несколько, однако их количество не обязательно должно совпадать, то есть никак не зависит друг от друга. 
</li>
<li>
Один catch должен отличаться от другого по типу данных, то есть не может быть двух catch с одинаковым типом.
</li>
</ol>

<p>Для того, чтобы вам было легче понять данный материал, все последующие особенности мы будем рассматривать на простых примерах.</p>

<h5>Пример 1. Простой пример на исключение.</h5>

<example>

# include &lt;iostream&gt;
using namespace std;

void main(){
	
	// Данная фраза появится на экране
	// сразу же при запуске программы
	cout&lt;&lt;"\nStart!!!\n";

	// вход в исключительный блок
	try{
		// выполнение показа на экран
		cout&lt;&lt;"\nBefore!\n";

		// прерывание блока try
		// возбуждение исключения типа int
		// выход из try
		throw 100;

		// данная фраза не появится
		// на экране никогда 
		cout&lt;&lt;"\nAfter!\n";
	}

	// блок для отлова исключения типа int
	// значение 100 попадёт в g
	catch(int g){

		// результат анализа исключения
		cout&lt;&lt;"\nException!!!!\n";

	}

	// показ завершающей строки на экран
	cout&lt;&lt;"\nBye!!!\n";
}
<b>
___________________________

Результат работы программы:
___________________________

Start!!!

Before!

Exception!!!!

Bye!!!
</b>
</example>

<h5>Пример 2. Исключение деления на нуль.</h5>

<example>

# include &lt;iostream&gt;
using namespace std;

void main(){

	// вход в исключительный блок	
	try{
		// создание переменных, запрос
		// и ввод данных с клавиатуры
		float a,b;

		cout&lt;&lt;"\nPut digit a:\n";
		cin&gt;&gt;a;

		cout&lt;&lt;"\nPut digit b:\n";
		cin&gt;&gt;b;

		// проверка делителя на нуль
		if(b==0){

			// если делитель нуль - возбуждение 
			// исключения типа float
			// выход из try	
		  	throw b;

		}

		// иначе блок успешно завершен
		cout&lt;&lt;"\nResult = "&lt;&lt;(a/b)&lt;&lt;"\n\n";
	}

	// сюда throw передаёт значение типа float 
	catch(float g){

		// анализ и сообщение об ошибке
		cout&lt;&lt;"\nError - Divide by "&lt;&lt;g&lt;&lt;"\n\n";
	}
	
}
</example>

<h5>Пример 3. Пример на несколько исключений.</h5>

<example>

# include &lt;iostream&gt;
using namespace std;

void main(){	
	
	// блок try способный возбудить
	// три исключения 
	try{

		// указатель и размер 
		// динамического массива
		int*ptr=0;
		int size;

		// ввод размера
		cout&lt;&lt;"\nPut size:\n";
		cin&gt;&gt;size;

		// если размер выходит за пределы
		// заданно го диапазона
		if(size&lt;1||size&gt;500)
			// возбуждаем исключение типа char*
			// блок try обрывается
			throw "\n\nErr Size!!!\n\n";

		// иначе создаем массив
		ptr=new int [size];

		// проверяем, выделилась ли память
		if(!ptr)
			// если нет возбуждаем 
			// исключение типа char*
			// блок try обрывается
		  	throw "\n\nErr Memory!!!\n\n";
		
		// иначе создаем тестовую переменную a
		// осуществляем ввод данных с
		// клавиатуры
		int a;
		cout&lt;&lt;"\nPut digit a:\n";
		cin&gt;&gt;a;

		
		if(a==0)
			// если a равно 0 возбуждаем 
			// исключение типа int
			// блок try обрывается
			throw a;
			

	}

	// отлов всех исключений типа int
	catch(int s){
		cout&lt;&lt;"\nError - A = "&lt;&lt;s&lt;&lt;"\n\n";
	}

	// отлов всех ислючений типа char*
	catch(char*s){
		cout&lt;&lt;s;
	}
	
}

</example>

<h5>Пример 4. Универсальный catch.</h5>
<p>
Если срабатывает throw с типом данных не имеющим эквивалента в catch, то программа будет автоматически закрыта. При этом произойдёт ошибка и (при нажатии кнопки ПРОПУСТИТЬ) на экране отобразится надпись - 
</p>
<p>
<b>
This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
</b>
</p>
<p>
Чтобы избежать данной ситуации обычно используют универсальный catch. Синтаксис его таков <b>catch(...){анализ;}</b> Обращаем Ваше внимание на то, что данная конструкция должна быть самой последний среди всех перечисленных catch!!! Если для какого-то исключения не будет найден соответствующий catch, выполнится универсальная конструкция.
</p>

<example>

# include &lt;iostream&gt;
using namespace std;

void main(){

	// вход в блок	
	try{
		// объявление и инициализация
		// переменной
		int a;
		cout&lt;&lt;"\nPut digit a:\n";
		cin&gt;&gt;a;		
		
		// если переменная равна нулю
		if(a==0)
			// генерация исключений 
			// типа char*
			throw "URRRRRRA!!!";
				
	}
	// универсальный catch
	catch(...){
		cout&lt;&lt;"\nSome Error!!!!\n\n";
	}
	
}

</example>

<h5>Пример 5. Генерация исключения внутри функции. (Вся обработка находится внутри функции).</h5>

<example>

# include &lt;iostream&gt;
using namespace std;

void Some(){

	// старый добрый анализ деления на нуль
	int a;
	int b;	

	try{

		cout&lt;&lt;"\nPut digit a:\n";
		cin&gt;&gt;a;		
		cout&lt;&lt;"\nPut digit b:\n";
		cin&gt;&gt;b;		

		// если делитель равен 0
		// генерируем исключение
		if(b==0)
			throw "\tZerro!!!\n";
				
	}
	// отлов исключения и анализ
	catch(char*s){
		cout&lt;&lt;"\n Error!!!!"&lt;&lt;s&lt;&lt;"\n\n";
	}
	
	
}

void main(){

	cout&lt;&lt;"\nFirst!!!\n";
	// вызов функции, содержащей исключение
	Some();
	cout&lt;&lt;"\nSecond!!!\n";

}

</example>

<h5>Пример 6. Генерация исключения внутри функции. (Внутри функции находится только возбуждение исключения).</h5>

<example>

# include &lt;iostream&gt;
using namespace std;

void Test(int t){

	// вход в функцию 	
	cout&lt;&lt;"\nInside!!!\n";

	if(t==2){
		// возбуждение исключения
		throw "\nError - t is 2\n";
	}

	else if(t==3){
		// возбуждение исключения
		throw "\nError - t is 3\n";
	}

}
void main(){

	// вызов функции заключается в тело try
	try{
		// вызовы
		Test(4);
		Test(2);				
	}
	// отлов исключений
	catch(char*s){
		cout&lt;&lt;"\n\n"&lt;&lt;s&lt;&lt;"\n\n";		
	}	
	
}

</example>

<h5>Пример 7. Повторная генерация исключения.</h5>

<p>Существует возможность внутри catch сгенерировать исключение еще раз:</p>

<example>

# include &lt;iostream&gt;
using namespace std;

void Test(){	
	try{
		// возбуждение исключения
		// первый раз
		throw "\nHello!!!\n";
	}

	// вход в анализ
	catch(char*s){

		cout&lt;&lt;"\n\nException!!!\n\n";	

		// передача исключения следующему catch	
		throw;
	}
	
}
void main(){

	cout&lt;&lt;"\nStart\n";

	try{

		// вызов функции с повторным исключением 
		// заключается в блок try
		Test();
		
	}
	// отлов объекта, посланного повторно
	catch(char*p){

		cout&lt;&lt;p;

	}	
	
}

</example>

<hr/>

<p>
Здесь мы постарались охватить все особенности работы с исключениями. Надеемся, что вы прониклись необходимостью их использования.
</p>

</lesson>
