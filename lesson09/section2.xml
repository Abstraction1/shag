<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №9" next="section3.xml" prev="section1.xml" summ="0">	  

<h2>Перегрузка функций.</h2>
<p>
Каждый раз, когда мы изучаем, новую тему, нам важно узнать, в чем заключается применение наших знаний на практике. Цель перегрузки функций состоит в том, чтобы несколько функций обладая одним именем, по-разному выполнялись и возвращали разные значения при обращении к ним с разными по типам и количеству фактическими параметрами.
</p>
<p> 
Например, может потребоваться функция, возвращающая максимальное из значений элементов одномерного массива, передаваемого ей в качестве параметра. Массивы, используемые как фактические параметры, могут содержать элементы разных типов, но пользователь функции не должен беспокоиться о типе результата. Функция всегда должна возвращать значение того же типа, что и тип массива - фактического параметра.
</p>
<p>
Для реализации перегрузки функций необходимо для каждого имени определить, сколько разных функций связано с ним, т.е. сколько вариантов вызовов допустимы при обращении к ним. Предположим, что функция выбора максимального значения элемента из массива должна работать для массивов типа int, long, float, double. В этом случае придется написать четыре разных варианта функции с одним и тем же именем. В нашем примере эта задача решена следующим образом: 
</p>
<example>
#include &lt;iostream&gt;
using namespace std;

long max_element(int n, int array[]) 
// Функция для массивов с элементами типа int.
{ 
	int value = array[0];     
	for (int i = 1; i &lt; n; i++)	
		value = value &gt; array [i] ? value : array [i] ;
	cout &lt;&lt; "\nFor (int)    : ";
	return long(value);
}

long max_element(int n, long array[]) 
// Функция для массивов с элементами типа long.
{ 
	long value = array[0];    
	for (int i = 1; i &lt; n; i++)	
		value = value &gt; array[i] ? value : array[i];
	cout &lt;&lt; "\nFor (long)   : ";
	return value;
}

double max_element(int n, float array[]) 
// Функция для массивов с элементами типа float.
{ 
	float value = array[0];   
	for (int i = 1; i &lt; n; i++)	
		value = value &gt; array[i] ? value : array[i];
	cout &lt;&lt; "\nFor (float)  : ";
	return double(value);
}

double max_element(int n, double array[]) 
// Функция для массивов с элементами типа double.
{ 
	double value = array[0];  
	for (int i = 1; i &lt; n; i++)	
		value = value &gt; array[i] ? value : array[i];
	cout &lt;&lt; "\nFor (double) : ";
	return value;
}

void main()
{ 
	int x[] = { 10, 20, 30, 40, 50, 60 };
	long f[] = { 12L, 44L, 5L, 22L, 37L, 30L }; 
	float y[] = { 0.1, 0.2, 0.3, 0.4, 0.5, 0.6 }; 
	double z[] = { 0.01, 0.02, 0.03, 0.04, 0.05, 0.06 }; 
	cout &lt;&lt; "max_elem(6,x) = " &lt;&lt; max_element(6,x); 
	cout &lt;&lt; "max_elem(6,f) = " &lt;&lt; max_element(6,f); 
	cout &lt;&lt; "max_elem(6,y) = " &lt;&lt; max_element(6,y); 
	cout &lt;&lt; "max elem(6,z) = " &lt;&lt; max_element(6,z);
}
</example>
<p>1. В программе мы показали независимость перегруженных функций от типа возвращаемого значения. Две функции, обрабатывающие целые массивы (int, long), возвращают значение одного типа long. Две функции, обрабатывающие вещественные массивы (double, float), обе возвращают значение типа double.</p>
<p>2. Распознавание перегруженных функций при вызове выполняется по их параметрам. Перегруженные функции должны иметь одинаковые имена, но спецификации их параметров должны различаться по количеству и (или) по типам, и (или) по расположению. </p>


<h5>ВНИМАНИЕ!!!</h5>
<p><u>При использовании перегруженных функций нужно с осторожностью задавать начальные значения их параметров.</u> Предположим, мы следующим образом определили перегруженную функцию умножения разного количества параметров:</p>
<example>
double multy (double x) {
	return x * х * х;
}
double multy (double x, double у) {
	return x * у * у;
}
double multy (double x, double у, double z)
{
	return x * у * z;
}
</example>
<p>Каждое из следующих обращений к функции multy() будет однозначно идентифицировано и правильно обработано:</p>
<example>
    multy (0.4) 
    multy (4.0, 12.3) 
    multy (0.1, 1.2, 6.4)
</example>
<p>Однако, добавление в программу функции с начальными значениями параметров: </p>
<example>
double multy (double a = 1.0, double b	= 1.0, double с = 1.0, double d = 1.0)
{
	return a * b + c * d;
}					
</example>
<p>навсегда запутает любой компилятор при попытках обработать, например, такой вызов:</p>
<example>
	multy(0.1, 1.2);
</example>
<p>что приведет к ошибке на этапе компиляции. Будьте внимательны!!!</p>
<hr/>
<p>Следующий раздел урока расскажет вам об альтернативном решении, позволяющем создать универсальную функцию.</p>
</lesson>
