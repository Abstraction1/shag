<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №9" next="hometask.xml" prev="section2.xml" summ="0">
<h2>Шаблоны функций. </h2>

<p>
Шаблоны функций в языке С позволяют создать общее определение функции, применяемой для различных типов данных.
</p>
<p>
В прошлой теме, чтобы использовать одну и ту же функцию с различными типами данных мы создавали отдельную перегруженную версию этой функции для каждого типа. Например:</p>
<example>
int Abs(int N)
{
  return N &lt; 0 ? -N : N;
}

double Abs(double N)
{
  return N &lt; 0. ? -N : N;
}
</example>


<p>
Теперь, используя шаблон мы сможем реализовать <i><b>единственное</b></i> описание,  обрабатывающее значения любого типа:
</p>

<example>
template &lt;typename T&gt; T Abs (T N)
{
  return N &lt; 0 ? -N : N;
}
</example>
<p>Теперь - обсудим то, что у нас получилось.</p>

<p>
1. Идентификатор <b>T</b> является <b><i>параметром типа</i></b>. Именно он определяет тип параметра, передаваемого в момент вызова функции.</p>
<p>2. Допустим, программа вызывает функцию <i>Abs</i> и передает ей значения типа <i>int</i>:</p>
<example>
cout &lt;&lt; "Result - 5 = " &lt;&lt; Abs(-5);
</example>
<p>3. В данном случае, компилятор автоматически создает версию функции, где вместо <b>T</b> подставляется тип <i>int</i>.</p>
<p>4. Теперь функция будет выглядеть так:</p>
<example>
int Abs (int N)
{
  return N &lt; 0 ? -N : N;
}
</example>

<p>
5. Следует отметить, что компилятор создаст версии функции для любого вызова, с любым типом данных. Такой процесс носит название - <i><b>создание экземпляра</b></i> шаблона функции.
</p>

<h3>Основные принципы и понятия при работе с шаблоном.</h3>
<p>Теперь, после поверхностного знакомства - мы рассмотрим все особенности работы шаблонов:</p>

<p>1. При определении шаблона используются два спецификатора: <b>template</b> и <b>typename</b>.</p>
<p>2. На место параметра типа <b>Т</b> можно подставить любое корректное имя.</p>
<p>3. В угловые скобки можно записывать больше одного параметра типа.</p>
<p>4. Параметр функции - это значение, передаваемое в функцию при выполнении программы.</p>
<p>5. Параметр типа - указывает тип аргумента, передаваемого в функцию, и обрабатывается только при компиляции.</p>

<h3>Процесс компиляции шаблона.</h3>

<p>1. Определение шаблона не вызывает генерацию кода компилятором самостоятельно. Последний создает код функции только в момент её вызова и генерирует при этом соответствующую версию функции.</p>
<p>2. Следующий вызов с теми же типами данных параметров не спровоцирует генерацию дополнительной копии функции, а вызовет ее уже существующую копию.</p>
<p>3. Компилятор создает новую версию функции, только если тип переданного параметра не совпадает ни с одним из предыдущих вызовов.</p>

<h3>Пример работы с шаблоном.</h3>

<example>
template &lt;typename T&gt; T Max (T A, T B)
{
  return A &gt; B ? A : B;
}
</example>
<p>1. Шаблон генерирует множество функций, возвращающих большее из двух значений с одинаковым типом данных.</p>
<p>2. Оба параметра определены как параметры типа <b>T</b> и при вызове функции передаваемые переметры должны быть строго одного типа. В данном случае возможны такие вызовы функции: </p>
<example>
cout &lt;&lt; "Большее из 10 и 5 = " &lt;&lt; Max(10, 5) &lt;&lt; "\n";
cout &lt;&lt; "Большее из 'A' и 'B' = " &lt;&lt; Max('A', 'B') &lt;&lt; "\n";
cout &lt;&lt; "Большее из 3.5 и 5.1 = " &lt;&lt; Max(3.5, 5.1) &lt;&lt; "\n";
</example>

<p>А такой вызов приведет к ошибке:</p>

<example>
cout &lt;&lt; "Большее из 10 и 5.55 = " &lt;&lt; Max(10, 5.55); // ОШИБКА!
</example>

<p>Компилятор не сможет преобразовать параметр <i>int</i> в <i>double</i>.</p>

<p>
Решением проблемы передачи разных параметров является такой шаблон:</p>
<example>

template &lt;typename T1, typename T2&gt; T2 Max(T1 A , T2 B)
{
   return A &gt; B ? A : B;
}

</example>
<p>
В этом случае <i>Т1</i> обозначает тип значения, передаваемого в качестве первого параметра, а <i>Т2</i> - второго.
</p>



<h5>ВНИМАНИЕ!!!</h5>

<p>Каждый параметр типа, встречающийся внутри угловых скобок, должен ОБЯЗАТЕЛЬНО появляться в списке параметров функции. В противном случае произойдет ошибка на этапе компиляции.</p>

<example>
template &lt;typename T1, typename T2&gt; T1 Max(T1 A , T1 B) 
{
  return A &gt; B ? A : B;
}
// ОШИБКА! список параметров должен включать T2 как параметр типа.
</example>

<h3>Переопределение шаблонов функций</h3>
<p>
1. Каждая версия функции, генерируемая с помощью шаблона, содержит один и тот же фрагмент кода.</p>
<p>2. Однако, для отдельных параметров типа можно обеспечить особую реализацию кода, т. е. определить обычную функцию с тем же именем, что и шаблон.</p>
<p>3. Обычная функция переопределит шаблон. Если компилятор находит типы переданных параметров соответствующие спецификации обычной функции, то он вызовает ее, и не создает функцию по шаблону. </p>
<hr/>
<p>На сегодня всё!!! Желаем удачи.</p>
</lesson>