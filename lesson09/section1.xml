<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №9" next="section2.xml" prev="index.xml" summ="1">
<h2>Встраивание.</h2>
<h3>Ключевое слово inline.</h3>
<p>В прошлом уроке мы познакомились с понятием функции. И выяснили, что как только программа встречает вызов функции, она сразу же обращается к телу данной функции и выполняет его. Этот процесс существенно сокращает код программы, но при этом увеличивает время ее выполнения за счет постоянных обращений к описанию конкретной вызванной функции. Но, бывает и не так. Некоторые функции в языке C можно определить с использованием специального служебного слова inline.</p>
<p>Данный спецификатор позволяет определить функцию как встраиваемую, то есть подставляемую в текст программы в местах обращения к этой функции. Например, следующая функция определена как подставляемая:</p>
<example>
inline float module(float x = 0, float у = 0) 
{ 
	return sqrt(x * x + у * у); 
}
</example>
<p> Обрабатывая каждый вызов встраиваемой функции <b>module</b>, компилятор подставляет на место ее вызова - в текст программы - код операторов тела функции. Тем самым при многократных вызовах подставляемой функции, размер программы может увеличиться, однако исключаются временные затраты на обращение к вызываемой функции и возврат из нее в основную функцию программы.</p>
<tip start="Примечание">
	Наиболее эффективно использовать подставляемые функции в тех случаях, когда тело функции состоит всего из нескольких операторов. 
</tip>
<p>Случается так, что компилятор не может определить функцию, как встраиваемую и просто игнорирует ключевое слово inline. Перечислим причины, которые приводят к такому результату:</p>
<p>1. Слишком большой размер функции.</p>
<p>2. Функция является рекурсивной. (с этим понятием вы познакомитесь в следующих уроках)</p> 
<p>3. Функция повторяется в одном и том же выражении несколько раз</p>
<p>4. Функция содержит цикл, switch или if.</p> 
<p>Как видите - всё просто, но inline-функции не единственный способ встраивания. Об этом расскажет следующая тема урока.</p>
<h3>Раскрытие макро.</h3>
<p>Помимо вызова функции, для встраивания в программу повторяющегося фрагмента используют, так называемое, <b>раскрытие макро</b>. Для этих целей применяется директива препроцессора #define, со следующим синтаксисом:</p>
<example>
#define Имя_макроса(Параметры) (Выражение) 
</example>
<h5>Пример.</h5>
<example>
#include &lt;iostream&gt;

#define SQR(X) ((X) * (X)) 
#define CUBE(X) (SQR(X)*(X)) 
#define ABS(X) (((X) &lt; 0)? -(X) : X)

using namespace std;
void main() 
{ 
	у = SQR(t + 8) - CUBE(t - 8) ; 
	cout &lt;&lt;sqrt(ABS(y)) ; 
}
</example>

<p>1. C помощью директивы #define объявляются три макроса sqr(x), cube(x) и abs(x).</p>
<p>2. В функции main происходит вызов вышеописанных макросов по имени.</p>
<p>3. Препроцессор раскрывает макро (т. е. подставляет на место вызова выражение из директивы #define) и передает получившийся текст компилятору.</p>
<p>4. После встраивания выражение в main выглядит для программы таким образом:</p>
<example> 	
	у = ((t+8) * (t+8)) - ((((t-8)) * (t-8)) * (t-8)); 
	cout &lt;&lt; sqrt(((y &lt; 0)? -(y) : y)); 
</example>

<tip start="Примечание">Следует обратить внимание на использование скобок при объявлении макроса. С помощью них мы избегаем ошибок в последовательности вычислений. Например:
<example> 
	#define SQR(X) X * X 
	у = SQR(t + 8); //раскроет макро t+8*t+8
</example>
В примере при вызове макроса SQR сначала выполнится умножение 8 на t, а потом к результату прибавится значение переменной t и восьмерка, хотя очевидно, что нашей целью было получение квадрата суммы t+8.
</tip>

<hr/>
<p>
Теперь вы полностью знакомы с понятием встраивания и можете использовать его в своих программах.
</p>

</lesson>
