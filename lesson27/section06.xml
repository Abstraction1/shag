<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №27" next="section07.xml" prev="section04.xml" summ="0">
<h2>Шаблоны классов.</h2>
<p>
Как говориться, и снова - здравствуйте. Мы с вами изучали шаблоны и раньше. Однако, это были шаблоны функций. Что ж, никогда не стоит останавливаться на достигнутом. в С++ существует возможность определить, так называемый, обобщенный класс. Это значит, что Вы можете создать класс, который описывает все используемые в нем функции, но тип данных членов класса задается при создании объектов этого класса. Другими словами, когда Вам необходимо разработать класс, обрабатывающий значения с разными типами данных, то средства лучше шаблонов, вы не найдете. 
</p>

<p>
Общий синтаксис создания шаблона для класса таков:
</p> 

<example>

template &lt;class тип_данных&gt; class имя_класса { 


//....описание класса....... 


}; 
</example>

<h5>Комментарии.</h5>
<ul>
<li><b>тип_данных</b> - имя типа шаблона, которое в зависимости от ситуации будет замещаться реальным типом данных. Здесь можно определять несколько параметризированных типа данных, разделяя их запятой. 
</li>
<li>Внутри определения класса имя шаблона можно использовать в любом месте.
</li>
</ul>

<hr/>

<p>Для создания реализации класса-шаблона используется следующий синтаксис:</p>

<example>

имя_класса &lt;тип_данных&gt; объект; 
</example>

<h5>Комментарии.</h5>
<ul>
<li><b>тип_данных</b> - имя реального типа данных, который встанет на место типа-шаблона.</li>
</ul>

<tip start="Примечание"><b>Важно!!! Функции-члены шаблонного класса автоматически являются шаблонными. Кроме того, если Вы пишите реализацию этих функций внутри класса, их ненужно объявлять как шаблонные с помощью ключевого слова template. </b>
</tip>

<h5>Пример.</h5>


<example>
#include &lt;iostream&gt;
using namespace std;

//параметризованный класс
template &lt;class T&gt; class TestClass {
private:
	//объявим поле tempo
	//какого оно будет типа,
	//это можно будет выяснить ТОЛЬКО во 
	//время создания конкретного экземпляра класса
	T tempo;
public:
	TestClass(){tempo=0;}
	//тестируемая функция
    	T testFunc();
};

//функция-член класса TestClass
//Так как метод реализован вне класса, 
//используем явное упоминание template
template &lt;class T&gt;
T TestClass&lt;T&gt;::testFunc() {
	//программа выводит на экран количество байт
	//занимаемое переменной tempo, типа T
    	cout&lt;&lt;"Type's size is: "&lt;&lt;sizeof(tempo)&lt;&lt;"\n\n";
	return tempo;
}


void main()
{
	//создадим конкретные экземпляры класса TestClass
	//char
	TestClass&lt;char&gt; ClassChar;
	ClassChar.testFunc();
	//int
	TestClass&lt;int&gt; ClassInt;
	ClassInt.testFunc();
	//double
	TestClass&lt;double&gt; ClassDouble;
	ClassDouble.testFunc();
}

</example>


</lesson>