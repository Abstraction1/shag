<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №27" next="section02.xml" prev="index.xml" summ="1">
<h2>Односвязный список.</h2>
<p>
Сегодня мы с вами познакомимся с динамической структурой данных, которая представляет собой нечто похожее на безразмерный массив. Называется эта структура - <b>список</b>. Существует несколько разновидностей списков. Для начала мы рассмотрим - <b>односвязный или однонаправленный список.</b>
</p>
<p>
<b>Односвязный список</b> - это совокупность объектов, называемых элементами списка, в которой каждый объект содержит информацию о местоположении следующего, связанного с ним объекта. 
</p>

<p>
Если список располагается в оперативной памяти, то, как правило, информация для поиска следующего объекта - это адрес (указатель) в памяти. Если список хранится в файле на диске, то информация о следующем элементе может включать смещение элемента от начала файла, положение указателя записи/считывания файла, ключ записи и любую другую информацию, позволяющую однозначно отыскать следующий элемент списка.
</p>

<p>
Односвязный список создать и реализовать достаточно просто. Каждый элемент списка представляется структурой языка C++ с двумя полями:
</p> 
<p>1. Информационное поле, которое в общем случае может представлять собой произвольное количество полей разных типов. Вполне естественно, что если значением переменной p является указатель на элемент списка, то обращаясь к обозначению (p) с помощью стрелки (->) и имени соответствующего поля, можно манипулировать со значением любого поля информационной части.
</p> 
<p>
2. Указатель на следующий элемент списка.
</p> 
    
<p>
Итак, каждую пару будем называть звеном, а указатели, содержащиеся в каждом из звеньев, будем использовать для соединения звеньев в список. Такой способ представления упорядоченной последовательности звеньев называется сцеплением. С учетом вышесказанного, мы можем описать звено списка так: 
</p> 

<example>  

    //узел (звено) списка	
    struct node
    {
	//Информационный элемент звена списка 
	int value;

 	// Указатель на следующее звено списка 
      	node *next; 	
    };
</example>

<p>
Кроме того, чтобы иметь возможность оперировать со списком как с единым объектом, введем в употребление указатель-переменную phead (голова списка) и указатель-переменную ptail (хвост списка). Данные указатели указывают на первое и последнее звенья списка и описываются следующим образом: 
</p>

<example>

	//голова
    	node *phead;

	//хвост
	node *ptail;
</example>
<p>Теперь, когда мы рассмотрели основную концепцию, можно смело переходить к реализации.</p>

<h5>Формирование списка.</h5>
<ol>

<li>
Отведем место для указателей в статической памяти.
<example>	
    	node *phead;
	node *ptail;
</example>
<center><img src="images\1.jpg" ></img></center>
</li>

<li>
Зарезервируем место для динамического объекта.
<example>

	phead=new node;
</example> 
<center><img src="images\2.jpg" ></img></center>
</li>

<li>
Присвоим значение переменной ptail, и поместим в информационное поле значение элемента.
<example>

	ptail = phead;
    	ptail->value = "значение1";

</example> 
<center><img src="images\3.jpg" ></img></center>
</li>

<li>
Поместим в поле звена адрес еще одного - нового динамического объекта.
<example>

	ptail->next = new node;
</example> 
<center><img src="images\4.jpg" ></img></center>
</li>

<li>Переменная ptail должна содержать адрес последнего добавленного элемента, т. к. он добавлен в конец.
<example>

	ptail = ptail->next;
</example> 
<center><img src="images\5.jpg" ></img></center>
</li>

<li>Если требуется завершить построение списка, то в поле указателя последнего элемента нужно поместить NULL. 
<example>

	ptail->next = NULL;
    	ptail->value = "значение2";
</example> 
<center><img src="images\6.jpg" ></img></center>
</li>

</ol>

<p>В результате построен линейный односвязный список, содержащий два узла.</p>

<h5>Вставка узла в определенное заданное место списка.</h5>

<tip start="Примечание">
Здесь и далее, мы не будем приводить фрагменты кода, так как они являются крупными. Позже мы с вами просто рассмотрим пример реализации односвязного списка целиком. А, сейчас, разберем операции над списком с помощью иллюстраций.
</tip>

<ol>
<li>Выделить память под новый узел.</li>
<li>Записать в новый узел значение.</li>
<li>Записать в указатель на следующий узел адрес узла, который должен располагаться после нового узла.</li>
<li>Заменить в узле, который будет располагаться перед новым узлом, записанный адрес на адрес нового узла. </li>
</ol>

<center><img src="images\7.jpg" ></img></center>

<h5>Удаление узла из списка.</h5>

<ol>
<li>Записать адрес узла, следующего за удаляемым узлом, в указатель на следующий узел в узле, предшествующем удаляемому.</li>
<li>Удалить узел, предназначенный для удаления.</li>
</ol>
<center><img src="images\8.jpg" ></img></center>
<hr/>
<p>Ну что ж, пора переходить к практике - смотрим пример в следующем разделе урока.</p>
</lesson>