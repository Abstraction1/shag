<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №28" next="section02.xml" prev="index.xml" summ="1">
<h2>Бинарное дерево.</h2>
<p>
Сегодня мы с вами познакомимся с новой, отнють не линейной структурой данных. Называется эта структура двоичное (или бинарное) дерево. Для начала дадим определение самой структуре, а затем рассмотрим несколько, терминов использующихся при работе с ней.
</p>

<p>
<b>Бинарное дерево (binary tree)</b> - это упорядоченная древовидная динамическая структура. Каждый элемент (узел) дерева имеет не более двух элементов следующих за ним (потомков) и не более одного предыдущего (родителя). Рассмотрим схематичное изображение бинарного дерева:
</p>

<center><img src="images\1.jpg" ></img></center>

<h5>Комментарии к изображению дерева. Терминология.</h5>
<ol>
<li>
Самый главный принцип бинарного дерева заключается в том, что для каждого узла выполняется правило: <b>в левой ветке содержатся только те ключи, которые имеют значения, меньшие, чем значение данного узла. В правой же ветке содержатся ключи, имеющие значения, большие, чем значение данного узла.</b>
</li>
<li>
Каждый узел может иметь два, одного или ни одного потомка.
</li>
<li>
<b>Лист</b> - узел, не имеющий потомков.
</li>
<li>
Узел является родительским для своих потомков и дочерним для своего предка.
</li>
<li>
<b>Левый потомок</b> - дочерний узел слева от текущего узла.
</li>
<li>
<b>Правый потомок</b> - дочерний узел справа от текущего узла.
</li>
<li>
<b>Корень</b> - основной узел, не имеющий родителей.
</li>
<li>
Каждый узел состоит из четырех частей: 
	<ul>
		<li>
		Значение.
		</li>
		<li>
		Указатель на родителя.
		</li>
		<li>
		Указатель на левого потомка.
		</li>
		<li>
		Указатель на правого потомка.
		</li>
	</ul>
</li>

</ol>

<center><img src="images\2.jpg" ></img></center>

<tip start= "Примечание">
Бинарное дерево является рекурсивной структурой, поскольку каждое его поддерево само является бинарным деревом и, следовательно, каждый его узел в свою очередь является корнем самостоятельного дерева.
</tip>

<h4>Организация работы с деревом.</h4>

<p>
При работе с деревьями обычно используются рекурсивные алгоритмы. Использование рекурсивных функций менее эффективно, поскольку многократный вызов функции расходует системные ресурсы. Тем не менее, в данном случае использование рекурсивных функций является оправданным, поскольку нерекурсивные функции для работы с деревьями гораздо сложнее и для написания, и для восприятия кода программы. Здесь мы приведем схематичные алгоритмы работы с деревом. А, осмысленный, практический пример смотрите в следующем разделе урока. Вот некоторые значения, которые мы будем использовать в схемах: 
</p>
<ul>
<li>x - вершина бинарного дерева</li>
<li>left[x] - левое поддерево</li>
<li>right[x] - правое поддерево</li>
<li>key[x] - ключ</li>
<li>p[x] - родитель вершины</li>
</ul>

<h5>Обход всего дерева.</h5>
<p>Печать(x)</p>
<p>Начало</p>
<ol>
<li>если x не равен NULL</li>
<li>тогда Печать(left[x])</li>
<li>напечатать key[x]</li>
<li>Печать(right[x])</li>
</ol>
<p>Конец</p>

<h5>Поиск значения.</h5>
<p>Поиск(x,k)</p>
<p>Начало</p>
<ol>
<li>Пока x не равен NULL и k не равно key[x]
</li>
<li>Начало
</li>
<li>если k меньше key[x]
</li>
<li>тогда x равно left[x]
</li>
<li>иначе x равно right[x]</li>
<li>Конец</li>
<li>Вернуть x</li>
</ol>
<p>Конец</p>
<h5>Нахождение минимума и максимума.</h5>

<p>Минимум(x)</p>
<p>Начало</p>
<ol>
<li>Пока left[x] не равен NULL
</li>
<li>Начало
</li>
<li>x=left[x]</li>
<li>Конец</li>
<li>Вернуть x </li>
</ol>
<p>Конец</p>

<p>Максимум(x)</p>
<p>Начало</p>
<ol>
<li>Пока right[x] не равен NULL</li>
<li>Начало
</li>
<li>x=right[x]</li>
<li>Конец</li>
<li>Вернуть x</li>
</ol>
<p>Конец</p>

<h5>Получение следующего и предыдущего элементов.</h5>

<p>ПолучитьСледующийЭлемент(x)</p>
<p>Начало</p>
<ol>
<li>если right[x] не равен NULL, тогда вернуть Минимум(right[x]) </li>
<li>y равно p[x]</li>
<li>пока y не равно NULL и x равно right[x]</li>
<li>Начало</li>
<li>x равно y</li>
<li>y равно p[y]</li>
<li>Вернуть y</li>
</ol>
<p>Конец</p>

<p>ПолучитьПредыдущийЭлемент(x)</p>
<p>Начало</p>
<ol>
<li>если left[x] не равен NULL, тогда вернуть Максимум(left[x])</li>
<li>y равно p[x]</li>
<li>пока y не равно NULL и x равно left[x]</li>
<li>Начало</li>
<li>x равно y</li>
<li>y равно p[y]</li>
<li>Вернуть y</li>
</ol>
<p>Конец</p>

<h5>Добавление значения.</h5>

<p>Вставка(T,z)</p>
<p>Начало</p>
<ol>
<li>y равно NULL</li>
<li>x равно root[T]</li>
<li>пока x не равно NULL</li>
<li>Начало</li>
<li>y равно x</li>
<li>если  key[z] меньше key[x], тогда x равно left[x]</li>
<li>иначе x равно right[x]</li>
<li>Конец</li>
<li>p[z] равно y</li>
<li>если y равно NULL, тогда root[T]  равно z</li>
<li>иначе если key[z] меньше key[y], тогда left[y] равно z</li>
<li>иначе right[y] равно z</li>
</ol>
<p>Конец</p>

<h5>Удаление значения.</h5>
<p>Удаление(T,z)</p>
<p>Начало</p>
<ol>
<li>если left[z] равно NULL или right[z]=NULL, тогда y равно z</li>
<li>иначе y равно ПолучитьСледующийЭлемент(z)</li>
<li>если left[y] не равно NULL, тогда x равно left[y]</li>
<li>иначе x равно right[y]</li>
<li>если x не равно NULL, тогда p[x] равно p[y]</li>
<li>если p[y] равно NULL, тогда root[T] равно x</li>
<li>иначе если y равно left[p[y]], тогда left[p[y]] равно x</li>
<li>иначе right[p[y]] равно x</li>
<li>если y не равен z, тогда key[z] равно key[y]</li>
<li>Копируем дополнительные данные связанные с y</li>
<li>Удалить y</li>
</ol>
<p>Конец</p>
<hr/>
<h5>Применение.</h5>
<p>
В заключение, отметим, что организация данных с помощью бинарных деревьев часто позволяет значительно сократить время поиска нужного элемента. Поиск элемента в линейных структурах данных обычно осуществляется путем последовательного перебора всех элементов, присутствующих в данной структуре. Поиск по дереву не требует перебора всех элементов, поэтому занимает значительно меньше времени. Максимальное число шагов при поиске по дереву равно высоте данного дерева, т.е. количеству уровней в иерархической структуре дерева.
</p>
</lesson>