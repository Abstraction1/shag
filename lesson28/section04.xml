<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №28" next="section06.xml" prev="section03.xml" summ="0">
<h2>Функции для работы с файлами библиотеки языка C.</h2>
<p>
После краткого экскурса в теорию файлов, пора переходить к практике. Данный раздел урока посвящается описанию функций для работы с файлами. Эти функции понадобятся нам для решения задач с использованием файлов.
</p>
<hr/>
<h4>Функции библиотеки stdio.h</h4>
<hr/>
<example>
<p><b>FILE *fopen(const char *filename, const char *mode)</b></p>
</example>
<p>Функция открывает файл.</p>
<p>filename - путь к файлу</p>
<p>mode - тип доступа</p> 
<ul>
<li>r - чтение, если файла нет, то данная функция генерирует ошибку (возвращает 0)</li> <li>w - запись, если файла нет, то файл создаётся, если есть исходное содержимое удаляется</li> 
<li>a - добавление в конец, если файла нет, то он создаётся</li> 
<li>r+ чтение и запись (файл должен существовать)</li> 
<li>w+ - чтение и запись (принцип работы как у w)</li> 
<li>a+ - добавление и чтение (принцип работы как у a)</li>
</ul>
<tip start="Примечание">
Все вышеописанные режимы предназначены для текстового открытия файла. Для двоичного открытия перед режимом достаточно добавить букву b. Например, br.</tip>
<p>
Если функция отработала успешно, из неё возвращается указатель на открытый файл, в противном случае - нуль. 
</p>
<tip start="Примечание">
Указатель на открытый файл принято хранить в типе данных FILE*.
</tip>
<hr/>
<example>
<p><b>int fclose( FILE *stream )</b></p>
</example>
<p>Функция закрывает файл.</p>
<p>stream - указатель на закрываемый файл.</p>
<p>
Если всё проходит успешно, то данная функция возвращает 0, или EOF в случае ошибки.
</p>
<tip start="Примечание">
EOF (End Of File) - обозначение конца файла.
</tip>
<hr/>

<example>
<p><b>char *fgets( char *string, int n, FILE *stream )</b></p>
</example>
<p>Считывает строку начиная с текущей позиции.</p>
<p>Считывание останавливается:</p>
<ul>
<li> ...если был найден символ перехода на новую строчку ( он помещается в строку )</li>
<li> ...если достигнут конец файла</li>
<li> ...если считано n-1 символов.</li>
</ul>
<p>string - cтрока, в которую попадают считанные данные</p>
<p>n - количество элементов в string</p>
<p>stream - указатель на открытый файл</p> 
<p>Если всё прошло успешно функция возвращает считанную строку, если произошла ошибка или достигнут конец файла возвращается 0.
</p> 
<hr/>


<example>
<p><b>int fputs( const char *string, FILE *stream )</b></p>
</example>
<p>Записывает строку в файл, начиная с текущей позиции.</p>
<p>string - строка для записи</p>
<p>stream - указатель на открытый файл, куда производиться запись</p>
<p>Если функция отрабатывает успешно из неё возвращается неотрицательное значение. При ошибке возвращается EOF.</p> 
<hr/>
<example>
<p><b>size_t fread( void *buffer, size_t size, size_t count, FILE *stream )</b></p>
</example>
<p>Функция считывает данные из файла в буфер.</p>
<p>buffer - адрес массива, куда запишутся данные</p>
<p>size - размер элемента массива в байтах</p>
<p>count - максимальное количество элементов для считывания</p>
<p>stream - указатель на открытый файл.</p>
<p>Функция возвращает количество считанных байт.</p>

<tip start="Примечание">
Тип данных size_t определен в библиотеке stdio.h следующим образом:<b> typedef unsigned int size_t;</b>. Другими словами, это обычный беззнаковый int.
</tip>
<hr/>

<example>
<p><b>size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream )</b></p>
</example>

<p>Функция записывает массив данных в файл.</p>
<p>buffer - адрес массива, где содержатся данные</p>
<p>size - размер элемента массива в байтах</p>
<p>count - максимальное количество элементов для записи в файл</p>
<p>stream - указатель на открытый файл.</p>
<p>Функция возвращает количество записанных байт.</p>
<hr/>
<example>
<p><b>int feof( FILE *stream )</b></p>
</example>

<p>Функция проверяет достигнут ли конец файла.</p>
<p>stream - указатель на открытый файл</p>
<p>Функция возвращает ненулевое значение, если достигнут конец файла, нуль возвращается в противном случае.</p>
<hr/>
<example>
<p><b>int _fileno( FILE *stream )</b></p>
</example>
<p>Данная функция возвращает дескриптор файла.</p>
<p>stream - указатель на открытый файл.</p>
<hr/>

<example>
<p><b>int fseek ( FILE *stream, int offset [, int whence] )</b></p>
</example>

<p>Устанавливает смещение в файле</p>
<p>stream - указатель на открытый файл</p>
<p>offset - смещение, измеряемое в байтах от начала файла</p>
<p>whence - точка, от которой производится смещение</p>
<ul>
<li>SEEK_SET (0) - начало файла</li>
<li>SEEK_CUR (1) - позиция текущего указателя файла</li>
<li>SEEK_END (2) - конец файла (EOF)</li>
</ul>
<p>Функция возвращает значение 0, если указатель файла успешно перемещен, и ненулевое значение в случае неудачного завершения.
</p>
<hr/>


<h4>Функции библиотеки io.h</h4>
<hr/>

<example>
<p><b>int _access( const char *path, int mode )</b></p>
</example>

<p>Функция определяет разрешения файла или директории.</p>
<p>path - путь к файлу или директории</p>
<p>mode - флаги для проверки</p>
<ul>
<li>00 - проверка на существование</li>
<li>02 - проверка на разрешение на запись</li>
<li>04 - проверка на разрешение на чтение</li>
<li>06 - проверка на чтение и запись</li>
</ul>
<p>Если разрешение есть, функция возвращает ноль, в случае отсутствия -1.</p>
<tip start="Примечание">
Директории можно проверять только на существование.
</tip>
<hr/>

<example>
<p><b>long _filelength( int handle )</b></p>
</example>
<p>Возвращает размер файла в байтах.</p>
<p>handle - дескриптор файла.</p>
<p>В случае ошибки функция возвращает -1.</p> 
<hr/>

<example>
<p><b>int _locking( int handle, int mode, long nbytes )</b></p>
</example>
<p>
Блокирует или разблокирует байты файла начиная с текущей позиции в файле.
</p>
<p>handle - дескриптор файла</p>
<p>mode - тип блокировки</p>
<ul>
<li>_LK_LOCK - блокирует байты, если заблокировать байты не получается попытка повторяется через 1 секунду.Если после 10 попыток байты не заблокируются функция генерирует ошибку и возвращает -1</li>
<li>_LK_NBLCK - блокирует байты, если заблокировать байты не получается функция генерирует ошибку и возвращает -1</li>
<li>_LK_NBRLCK - то же самое, что и _LK_NBLCK</li>
<li>_LK_RLCK - то же самое, что и _LK_LOCK</li>
<li>_LK_UNLCK - разблокировка байт, которые были до этого заблокированы</li>
</ul>
<p>nbytes - количество байт для блокировки</p>
<p>Функция locking возвращает -1, если происходит ошибка и 0 в случае успеха.</p>
<tip start="Примечание">Для работы этой функции кроме io.h, нужно подключить  sys/locking.h</tip>

<hr/>




</lesson>